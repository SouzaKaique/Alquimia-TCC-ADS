{
  "version": 3,
  "sources": ["../../../../../../../../../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs"],
  "sourcesContent": ["\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n\n", "\"use strict\";\nconst textureBit = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    )\n  }\n};\nconst textureBitGl = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureMatrix;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n        uniform sampler2D uTexture;\n\n\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            outColor = texture(uTexture, vUV);\n        `\n    )\n  }\n};\n\nexport { textureBit, textureBitGl };\n\n", "import { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported.mjs';\nimport { Buffer } from '../buffer/Buffer.mjs';\nimport { BufferUsage } from '../buffer/const.mjs';\n\n\"use strict\";\nclass UboSystem {\n  constructor(adaptor) {\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    this._syncFunctionHash = /* @__PURE__ */ Object.create(null);\n    this._adaptor = adaptor;\n    this._systemCheck();\n  }\n  /**\n   * Overridable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn't support unsafe-evals.\n   * @private\n   */\n  _systemCheck() {\n    if (!unsafeEvalSupported()) {\n      throw new Error(\"Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.\");\n    }\n  }\n  ensureUniformGroup(uniformGroup) {\n    const uniformData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({\n      data: new Float32Array(uniformData.layout.size / 4),\n      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\n    }));\n  }\n  getUniformGroupData(uniformGroup) {\n    return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n  }\n  _initUniformGroup(uniformGroup) {\n    const uniformGroupSignature = uniformGroup._signature;\n    let uniformData = this._syncFunctionHash[uniformGroupSignature];\n    if (!uniformData) {\n      const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n      const layout = this._adaptor.createUboElements(elements);\n      const syncFunction = this._generateUboSync(layout.uboElements);\n      uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n        layout,\n        syncFunction\n      };\n    }\n    return this._syncFunctionHash[uniformGroupSignature];\n  }\n  _generateUboSync(uboElements) {\n    return this._adaptor.generateUboSync(uboElements);\n  }\n  syncUniformGroup(uniformGroup, data, offset) {\n    const uniformGroupData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({\n      data: new Float32Array(uniformGroupData.layout.size / 4),\n      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\n    }));\n    let dataInt32 = null;\n    if (!data) {\n      data = uniformGroup.buffer.data;\n      dataInt32 = uniformGroup.buffer.dataInt32;\n    }\n    offset || (offset = 0);\n    uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);\n    return true;\n  }\n  updateUniformGroup(uniformGroup) {\n    if (uniformGroup.isStatic && !uniformGroup._dirtyId) return false;\n    uniformGroup._dirtyId = 0;\n    const synced = this.syncUniformGroup(uniformGroup);\n    uniformGroup.buffer.update();\n    return synced;\n  }\n  destroy() {\n    this._syncFunctionHash = null;\n  }\n}\n\nexport { UboSystem };\n\n", "\"use strict\";\nconst uniformParsers = [\n  // uploading pixi matrix object to mat3\n  {\n    type: \"mat3x3<f32>\",\n    test: (data) => {\n      const value = data.value;\n      return value.a !== void 0;\n    },\n    ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n    uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n  },\n  // uploading a pixi rectangle as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.width !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n  },\n  // uploading a pixi point as a vec2\n  {\n    type: \"vec2<f32>\",\n    test: (data) => data.type === \"vec2<f32>\" && data.size === 1 && data.value.x !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n  },\n  // uploading a pixi color as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n  },\n  // uploading a pixi color as a vec3\n  {\n    type: \"vec3<f32>\",\n    test: (data) => data.type === \"vec3<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n  }\n];\n\nexport { uniformParsers };\n\n", "import { uniformParsers } from './uniformParsers.mjs';\n\n\"use strict\";\nfunction createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {\n  const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n  let prev = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    const name = uboElement.data.name;\n    let parsed = false;\n    let offset = 0;\n    for (let j = 0; j < uniformParsers.length; j++) {\n      const uniformParser = uniformParsers[j];\n      if (uniformParser.test(uboElement.data)) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          `name = \"${name}\";`,\n          `offset += ${offset - prev};`,\n          uniformParsers[j][parserCode] || uniformParsers[j].ubo\n        );\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      if (uboElement.data.size > 1) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n      } else {\n        const template = singleSettersMap[uboElement.data.type];\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          /* wgsl */\n          `\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `\n        );\n      }\n    }\n    prev = offset;\n  }\n  const fragmentSrc = funcFragments.join(\"\\n\");\n  return new Function(\n    \"uv\",\n    \"data\",\n    \"dataInt32\",\n    \"offset\",\n    fragmentSrc\n  );\n}\n\nexport { createUboSyncFunction };\n\n", "\"use strict\";\nfunction loopMatrix(col, row) {\n  const total = col * row;\n  return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\nconst uboSyncFunctionsSTD40 = {\n  f32: `\n        data[offset] = v;`,\n  i32: `\n        dataInt32[offset] = v;`,\n  \"vec2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n  \"vec3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n  \"vec4<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n  \"vec2<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];`,\n  \"vec3<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];`,\n  \"vec4<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];`,\n  \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n  \"mat3x3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n  \"mat4x4<f32>\": `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n  \"mat3x2<f32>\": loopMatrix(3, 2),\n  \"mat4x2<f32>\": loopMatrix(4, 2),\n  \"mat2x3<f32>\": loopMatrix(2, 3),\n  \"mat4x3<f32>\": loopMatrix(4, 3),\n  \"mat2x4<f32>\": loopMatrix(2, 4),\n  \"mat3x4<f32>\": loopMatrix(3, 4)\n};\nconst uboSyncFunctionsWGSL = {\n  ...uboSyncFunctionsSTD40,\n  \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `\n};\n\nexport { uboSyncFunctionsSTD40, uboSyncFunctionsWGSL };\n\n", "import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nclass BufferResource extends EventEmitter {\n  /**\n   * Create a new Buffer Resource.\n   * @param options - The options for the buffer resource\n   * @param options.buffer - The underlying buffer that this resource is using\n   * @param options.offset - The offset of the buffer this resource is using.\n   * If not provided, then it will use the offset of the buffer.\n   * @param options.size - The size of the buffer this resource is using.\n   * If not provided, then it will use the size of the buffer.\n   */\n  constructor({ buffer, offset, size }) {\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"buffer\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    this._resourceType = \"bufferResource\";\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    this._touched = 0;\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     */\n    this._bufferResource = true;\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    this.buffer = buffer;\n    this.offset = offset | 0;\n    this.size = size;\n    this.buffer.on(\"change\", this.onBufferChange, this);\n  }\n  onBufferChange() {\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n  }\n  /**\n   * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n   * if you want to destroy it as well, or code will explode\n   * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n   */\n  destroy(destroyBuffer = false) {\n    this.destroyed = true;\n    if (destroyBuffer) {\n      this.buffer.destroy();\n    }\n    this.emit(\"change\", this);\n    this.buffer = null;\n    this.removeAllListeners();\n  }\n}\n\nexport { BufferResource };\n\n", "import { warn } from '../../../../../utils/logging/warn.mjs';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nfunction ensureAttributes(geometry, extractedData) {\n  for (const i in geometry.attributes) {\n    const attribute = geometry.attributes[i];\n    const attributeData = extractedData[i];\n    if (attributeData) {\n      attribute.format ?? (attribute.format = attributeData.format);\n      attribute.offset ?? (attribute.offset = attributeData.offset);\n      attribute.instance ?? (attribute.instance = attributeData.instance);\n    } else {\n      warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n    }\n  }\n  ensureStartAndStride(geometry);\n}\nfunction ensureStartAndStride(geometry) {\n  const { buffers, attributes } = geometry;\n  const tempStride = {};\n  const tempStart = {};\n  for (const j in buffers) {\n    const buffer = buffers[j];\n    tempStride[buffer.uid] = 0;\n    tempStart[buffer.uid] = 0;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);\n    attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);\n    tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n}\n\nexport { ensureAttributes };\n\n", "import { STENCIL_MODES } from '../../shared/state/const.mjs';\n\n\"use strict\";\nconst GpuStencilModesToPixi = [];\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n  stencilWriteMask: 0,\n  stencilReadMask: 0\n};\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: \"not-equal\",\n    passOp: \"keep\"\n  },\n  stencilBack: {\n    compare: \"not-equal\",\n    passOp: \"keep\"\n  }\n};\n\nexport { GpuStencilModesToPixi };\n\n"],
  "mappings": "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",
  "names": []
}
