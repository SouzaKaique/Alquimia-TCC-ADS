{
  "version": 3,
  "sources": ["../../../../../../../../../node_modules/earcut/src/earcut.js", "../../../../../../../../../node_modules/pixi.js/lib/utils/utils.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs", "../../../../../../../../../node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs", "../../../../../../../../../node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs", "../../../../../../../../../node_modules/pixi.js/lib/utils/data/GCManagedHash.mjs"],
  "sourcesContent": ["\nexport default function earcut(data, holeIndices, dim = 2) {\n\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    let outerNode = linkedList(data, 0, outerLen, dim, true);\n    const triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    let minX, minY, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = data[0];\n        minY = data[1];\n        let maxX = minX;\n        let maxY = minY;\n\n        for (let i = dim; i < outerLen; i += dim) {\n            const x = data[i];\n            const y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    let last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (let i = start; i < end; i += dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);\n    } else {\n        for (let i = end - dim; i >= start; i -= dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    let p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    let stop = ear;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        const prev = ear.prev;\n        const next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            triangles.push(prev.i, ear.i, next.i); // cut off the triangle\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    const a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox\n    const x0 = Math.min(ax, bx, cx),\n        y0 = Math.min(ay, by, cy),\n        x1 = Math.max(ax, bx, cx),\n        y1 = Math.max(ay, by, cy);\n\n    let p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    const a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox\n    const x0 = Math.min(ax, bx, cx),\n        y0 = Math.min(ay, by, cy),\n        x1 = Math.max(ax, bx, cx),\n        y1 = Math.max(ay, by, cy);\n\n    // z-order range for the current triangle bbox;\n    const minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    let p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles) {\n    let p = start;\n    do {\n        const a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i, p.i, b.i);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    let a = start;\n    do {\n        let b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                let c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    const queue = [];\n\n    for (let i = 0, len = holeIndices.length; i < len; i++) {\n        const start = holeIndices[i] * dim;\n        const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        const list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareXYSlope);\n\n    // process holes from left to right\n    for (let i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareXYSlope(a, b) {\n    let result = a.x - b.x;\n    // when the left-most point of 2 holes meet at a vertex, sort the holes counterclockwise so that when we find\n    // the bridge to the outer shell is always the point that they meet at.\n    if (result === 0) {\n        result = a.y - b.y;\n        if (result === 0) {\n            const aSlope = (a.next.y - a.y) / (a.next.x - a.x);\n            const bSlope = (b.next.y - b.y) / (b.next.x - b.x);\n            result = aSlope - bSlope;\n        }\n    }\n    return result;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and link it\nfunction eliminateHole(hole, outerNode) {\n    const bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    const bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    let p = outerNode;\n    const hx = hole.x;\n    const hy = hole.y;\n    let qx = -Infinity;\n    let m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    // unless they intersect at a vertex, then choose the vertex\n    if (equals(hole, p)) return p;\n    do {\n        if (equals(hole, p.next)) return p.next;\n        else if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    const stop = m;\n    const mx = m.x;\n    const my = m.y;\n    let tanMin = Infinity;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            const tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    let p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    let numMerges;\n    let inSize = 1;\n\n    do {\n        let p = list;\n        let e;\n        list = null;\n        let tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            let q = p;\n            let pSize = 0;\n            for (let i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            let qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    let p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a point lies within a convex triangle but false if its equal to the first point of the triangle\nfunction pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {\n    return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // doesn't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    const o1 = sign(area(p1, q1, p2));\n    const o2 = sign(area(p1, q1, q2));\n    const o3 = sign(area(p2, q2, p1));\n    const o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    let p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    let p = a;\n    let inside = false;\n    const px = (a.x + b.x) / 2;\n    const py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    const a2 = createNode(a.i, a.x, a.y),\n        b2 = createNode(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    const p = createNode(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction createNode(i, x, y) {\n    return {\n        i, // vertex index in coordinates array\n        x, y, // vertex coordinates\n        prev: null, // previous and next vertex nodes in a polygon ring\n        next: null,\n        z: 0, // z-order curve value\n        prevZ: null, // previous and next nodes in z-order\n        nextZ: null,\n        steiner: false // indicates whether this is a steiner point\n    };\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nexport function deviation(data, holeIndices, dim, triangles) {\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    let polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (let i = 0, len = holeIndices.length; i < len; i++) {\n            const start = holeIndices[i] * dim;\n            const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    let trianglesArea = 0;\n    for (let i = 0; i < triangles.length; i += 3) {\n        const a = triangles[i] * dim;\n        const b = triangles[i + 1] * dim;\n        const c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n}\n\nfunction signedArea(data, start, end, dim) {\n    let sum = 0;\n    for (let i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nexport function flatten(data) {\n    const vertices = [];\n    const holes = [];\n    const dimensions = data[0][0].length;\n    let holeIndex = 0;\n    let prevLen = 0;\n\n    for (const ring of data) {\n        for (const p of ring) {\n            for (let d = 0; d < dimensions; d++) vertices.push(p[d]);\n        }\n        if (prevLen) {\n            holeIndex += prevLen;\n            holes.push(holeIndex);\n        }\n        prevLen = ring.length;\n    }\n    return {vertices, holes, dimensions};\n}\n", "import earcutModule from 'earcut';\nexport { default as EventEmitter } from 'eventemitter3';\n\n\"use strict\";\nconst earcut = earcutModule.default || earcutModule;\n\nexport { earcut };\n\n", "import { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction addBits(srcParts, parts, name) {\n  if (srcParts) {\n    for (const i in srcParts) {\n      const id = i.toLocaleLowerCase();\n      const part = parts[id];\n      if (part) {\n        let sanitisedPart = srcParts[i];\n        if (i === \"header\") {\n          sanitisedPart = sanitisedPart.replace(/@in\\s+[^;]+;\\s*/g, \"\").replace(/@out\\s+[^;]+;\\s*/g, \"\");\n        }\n        if (name) {\n          part.push(`//----${name}----//`);\n        }\n        part.push(sanitisedPart);\n      } else {\n        warn(`${i} placement hook does not exist in shader`);\n      }\n    }\n  }\n}\n\nexport { addBits };\n\n", "\"use strict\";\nconst findHooksRx = /\\{\\{(.*?)\\}\\}/g;\nfunction compileHooks(programSrc) {\n  const parts = {};\n  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, \"\")) ?? [];\n  partMatches.forEach((hook) => {\n    parts[hook] = [];\n  });\n  return parts;\n}\n\nexport { compileHooks };\n\n", "\"use strict\";\nfunction extractInputs(fragmentSource, out) {\n  let match;\n  const regex = /@in\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction compileInputs(fragments, template, sort = false) {\n  const results = [];\n  extractInputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractInputs(fragment.header, results);\n    }\n  });\n  const mainInput = results;\n  if (sort) {\n    mainInput.sort();\n  }\n  const finalString = mainInput.map((inValue, i) => `       @location(${i}) ${inValue},`).join(\"\\n\");\n  let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, \"\");\n  cleanedString = cleanedString.replace(\"{{in}}\", `\n${finalString}\n`);\n  return cleanedString;\n}\n\nexport { compileInputs };\n\n", "\"use strict\";\nfunction extractOutputs(fragmentSource, out) {\n  let match;\n  const regex = /@out\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction extractVariableName(value) {\n  const regex = /\\b(\\w+)\\s*:/g;\n  const match = regex.exec(value);\n  return match ? match[1] : \"\";\n}\nfunction stripVariable(value) {\n  const regex = /@.*?\\s+/g;\n  return value.replace(regex, \"\");\n}\nfunction compileOutputs(fragments, template) {\n  const results = [];\n  extractOutputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractOutputs(fragment.header, results);\n    }\n  });\n  let index = 0;\n  const mainStruct = results.sort().map((inValue) => {\n    if (inValue.indexOf(\"builtin\") > -1) {\n      return inValue;\n    }\n    return `@location(${index++}) ${inValue}`;\n  }).join(\",\\n\");\n  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join(\"\\n\");\n  const mainEnd = `return VSOutput(\n            ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(\",\\n\")});`;\n  let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n  compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n  compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n  compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n  return compiledCode;\n}\n\nexport { compileOutputs };\n\n", "\"use strict\";\nfunction injectBits(templateSrc, fragmentParts) {\n  let out = templateSrc;\n  for (const i in fragmentParts) {\n    const parts = fragmentParts[i];\n    const toInject = parts.join(\"\\n\");\n    if (toInject.length) {\n      out = out.replace(`{{${i}}}`, `//-----${i} START-----//\n${parts.join(\"\\n\")}\n//----${i} FINISH----//`);\n    } else {\n      out = out.replace(`{{${i}}}`, \"\");\n    }\n  }\n  return out;\n}\n\nexport { injectBits };\n\n", "import { addBits } from './utils/addBits.mjs';\nimport { compileHooks } from './utils/compileHooks.mjs';\nimport { compileInputs } from './utils/compileInputs.mjs';\nimport { compileOutputs } from './utils/compileOutputs.mjs';\nimport { injectBits } from './utils/injectBits.mjs';\n\n\"use strict\";\nconst cacheMap = /* @__PURE__ */ Object.create(null);\nconst bitCacheMap = /* @__PURE__ */ new Map();\nlet CACHE_UID = 0;\nfunction compileHighShader({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId]) return cacheMap[cacheId];\n  const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n  cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileHighShaderGl({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId]) return cacheMap[cacheId];\n  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileInputsAndOutputs(template, bits) {\n  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n  compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n  return {\n    vertex: compiledVertex,\n    fragment: compiledFragment\n  };\n}\nfunction generateCacheId(template, bits) {\n  return bits.map((highFragment) => {\n    if (!bitCacheMap.has(highFragment)) {\n      bitCacheMap.set(highFragment, CACHE_UID++);\n    }\n    return bitCacheMap.get(highFragment);\n  }).sort((a, b) => a - b).join(\"-\") + template.vertex + template.fragment;\n}\nfunction compileBits(vertex, fragment, bits) {\n  const vertexParts = compileHooks(vertex);\n  const fragmentParts = compileHooks(fragment);\n  bits.forEach((shaderBit) => {\n    addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n  });\n  return {\n    vertex: injectBits(vertex, vertexParts),\n    fragment: injectBits(fragment, fragmentParts)\n  };\n}\n\nexport { compileHighShader, compileHighShaderGl };\n\n", "\"use strict\";\nconst vertexGPUTemplate = (\n  /* wgsl */\n  `\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n\n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`\n);\nconst fragmentGPUTemplate = (\n  /* wgsl */\n  `\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n\n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n\n        {{start}}\n\n        var outColor:vec4<f32>;\n\n        {{main}}\n\n        var finalColor:vec4<f32> = outColor * vColor;\n\n        {{end}}\n\n        return finalColor;\n      };\n`\n);\nconst vertexGlTemplate = (\n  /* glsl */\n  `\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n\n        {{start}}\n\n        vColor = vec4(1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`\n);\nconst fragmentGlTemplate = (\n  /* glsl */\n  `\n\n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n\n        {{start}}\n\n        vec4 outColor;\n\n        {{main}}\n\n        finalColor = outColor * vColor;\n\n        {{end}}\n    }\n`\n);\n\nexport { fragmentGPUTemplate, fragmentGlTemplate, vertexGPUTemplate, vertexGlTemplate };\n\n", "\"use strict\";\nconst globalUniformsBit = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    )\n  }\n};\nconst globalUniformsUBOBitGl = {\n  name: \"global-uniforms-ubo-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    )\n  }\n};\nconst globalUniformsBitGl = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    )\n  }\n};\n\nexport { globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl };\n\n", "import { GlProgram } from '../renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram.mjs';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader.mjs';\nimport { vertexGPUTemplate, fragmentGPUTemplate, fragmentGlTemplate, vertexGlTemplate } from './defaultProgramTemplate.mjs';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit.mjs';\n\n\"use strict\";\nfunction compileHighShaderGpuProgram({ bits, name }) {\n  const source = compileHighShader({\n    template: {\n      fragment: fragmentGPUTemplate,\n      vertex: vertexGPUTemplate\n    },\n    bits: [\n      globalUniformsBit,\n      ...bits\n    ]\n  });\n  return GpuProgram.from({\n    name,\n    vertex: {\n      source: source.vertex,\n      entryPoint: \"main\"\n    },\n    fragment: {\n      source: source.fragment,\n      entryPoint: \"main\"\n    }\n  });\n}\nfunction compileHighShaderGlProgram({ bits, name }) {\n  return new GlProgram({\n    name,\n    ...compileHighShaderGl({\n      template: {\n        vertex: vertexGlTemplate,\n        fragment: fragmentGlTemplate\n      },\n      bits: [\n        globalUniformsBitGl,\n        ...bits\n      ]\n    })\n  });\n}\n\nexport { compileHighShaderGlProgram, compileHighShaderGpuProgram };\n\n", "\"use strict\";\nconst colorBit = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            @in aColor: vec4<f32>;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\nconst colorBitGl = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            in vec4 aColor;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\n\nexport { colorBit, colorBitGl };\n\n", "\"use strict\";\nconst textureBatchBitGpuCache = {};\nfunction generateBindingSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n    src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n  } else {\n    let bindingIndex = 0;\n    for (let i = 0; i < maxTextures; i++) {\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n    }\n  }\n  return src.join(\"\\n\");\n}\nfunction generateSampleSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n  } else {\n    src.push(\"switch vTextureId {\");\n    for (let i = 0; i < maxTextures; i++) {\n      if (i === maxTextures - 1) {\n        src.push(`  default:{`);\n      } else {\n        src.push(`  case ${i}:{`);\n      }\n      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n      src.push(`      break;}`);\n    }\n    src.push(`}`);\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBit(maxTextures) {\n  if (!textureBatchBitGpuCache[maxTextures]) {\n    textureBatchBitGpuCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n        main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGpuCache[maxTextures];\n}\nconst textureBatchBitGlCache = {};\nfunction generateSampleGlSrc(maxTextures) {\n  const src = [];\n  for (let i = 0; i < maxTextures; i++) {\n    if (i > 0) {\n      src.push(\"else\");\n    }\n    if (i < maxTextures - 1) {\n      src.push(`if(vTextureId < ${i}.5)`);\n    }\n    src.push(\"{\");\n    src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n    src.push(\"}\");\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBitGl(maxTextures) {\n  if (!textureBatchBitGlCache[maxTextures]) {\n    textureBatchBitGlCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n        main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGlCache[maxTextures];\n}\n\nexport { generateTextureBatchBit, generateTextureBatchBitGl };\n\n", "\"use strict\";\nconst roundPixelsBit = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\nconst roundPixelsBitGl = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\n\nexport { roundPixelsBit, roundPixelsBitGl };\n\n", "\"use strict\";\nclass ViewableBuffer {\n  constructor(sizeOrBuffer) {\n    if (typeof sizeOrBuffer === \"number\") {\n      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n    } else if (sizeOrBuffer instanceof Uint8Array) {\n      this.rawBinaryData = sizeOrBuffer.buffer;\n    } else {\n      this.rawBinaryData = sizeOrBuffer;\n    }\n    this.uint32View = new Uint32Array(this.rawBinaryData);\n    this.float32View = new Float32Array(this.rawBinaryData);\n    this.size = this.rawBinaryData.byteLength;\n  }\n  /** View on the raw binary data as a `Int8Array`. */\n  get int8View() {\n    if (!this._int8View) {\n      this._int8View = new Int8Array(this.rawBinaryData);\n    }\n    return this._int8View;\n  }\n  /** View on the raw binary data as a `Uint8Array`. */\n  get uint8View() {\n    if (!this._uint8View) {\n      this._uint8View = new Uint8Array(this.rawBinaryData);\n    }\n    return this._uint8View;\n  }\n  /**  View on the raw binary data as a `Int16Array`. */\n  get int16View() {\n    if (!this._int16View) {\n      this._int16View = new Int16Array(this.rawBinaryData);\n    }\n    return this._int16View;\n  }\n  /** View on the raw binary data as a `Int32Array`. */\n  get int32View() {\n    if (!this._int32View) {\n      this._int32View = new Int32Array(this.rawBinaryData);\n    }\n    return this._int32View;\n  }\n  /** View on the raw binary data as a `Float64Array`. */\n  get float64View() {\n    if (!this._float64Array) {\n      this._float64Array = new Float64Array(this.rawBinaryData);\n    }\n    return this._float64Array;\n  }\n  /** View on the raw binary data as a `BigUint64Array`. */\n  get bigUint64View() {\n    if (!this._bigUint64Array) {\n      this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n    }\n    return this._bigUint64Array;\n  }\n  /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */\n  view(type) {\n    return this[`${type}View`];\n  }\n  /** Destroys all buffer references. Do not use after calling this. */\n  destroy() {\n    this.rawBinaryData = null;\n    this.uint32View = null;\n    this.float32View = null;\n    this.uint16View = null;\n    this._int8View = null;\n    this._uint8View = null;\n    this._int16View = null;\n    this._int32View = null;\n    this._float64Array = null;\n    this._bigUint64Array = null;\n  }\n  /**\n   * Returns the size of the given type in bytes.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *   `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - size of the type in bytes\n   */\n  static sizeOf(type) {\n    switch (type) {\n      case \"int8\":\n      case \"uint8\":\n        return 1;\n      case \"int16\":\n      case \"uint16\":\n        return 2;\n      case \"int32\":\n      case \"uint32\":\n      case \"float32\":\n        return 4;\n      default:\n        throw new Error(`${type} isn't a valid view type`);\n    }\n  }\n}\n\nexport { ViewableBuffer };\n\n", "\"use strict\";\nfunction fastCopy(sourceBuffer, destinationBuffer, sourceOffset, byteLength) {\n  sourceOffset ?? (sourceOffset = 0);\n  byteLength ?? (byteLength = Math.min(sourceBuffer.byteLength - sourceOffset, destinationBuffer.byteLength));\n  if (!(sourceOffset & 7) && !(byteLength & 7)) {\n    const len = byteLength / 8;\n    new Float64Array(destinationBuffer, 0, len).set(new Float64Array(sourceBuffer, sourceOffset, len));\n  } else if (!(sourceOffset & 3) && !(byteLength & 3)) {\n    const len = byteLength / 4;\n    new Float32Array(destinationBuffer, 0, len).set(new Float32Array(sourceBuffer, sourceOffset, len));\n  } else {\n    new Uint8Array(destinationBuffer).set(new Uint8Array(sourceBuffer, sourceOffset, byteLength));\n  }\n}\n\nexport { fastCopy };\n\n", "\"use strict\";\nconst BLEND_TO_NPM = {\n  normal: \"normal-npm\",\n  add: \"add-npm\",\n  screen: \"screen-npm\"\n};\nvar STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {\n  STENCIL_MODES2[STENCIL_MODES2[\"DISABLED\"] = 0] = \"DISABLED\";\n  STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_ADD\"] = 1] = \"RENDERING_MASK_ADD\";\n  STENCIL_MODES2[STENCIL_MODES2[\"MASK_ACTIVE\"] = 2] = \"MASK_ACTIVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"INVERSE_MASK_ACTIVE\"] = 3] = \"INVERSE_MASK_ACTIVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_REMOVE\"] = 4] = \"RENDERING_MASK_REMOVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"NONE\"] = 5] = \"NONE\";\n  return STENCIL_MODES2;\n})(STENCIL_MODES || {});\n\nexport { BLEND_TO_NPM, STENCIL_MODES };\n\n", "import { BLEND_TO_NPM } from './const.mjs';\n\n\"use strict\";\nfunction getAdjustedBlendModeBlend(blendMode, textureSource) {\n  if (textureSource.alphaMode === \"no-premultiply-alpha\") {\n    return BLEND_TO_NPM[blendMode] || blendMode;\n  }\n  return blendMode;\n}\n\nexport { getAdjustedBlendModeBlend };\n\n", "\"use strict\";\nconst fragTemplate = [\n  \"precision mediump float;\",\n  \"void main(void){\",\n  \"float test = 0.1;\",\n  \"%forloop%\",\n  \"gl_FragColor = vec4(0.0);\",\n  \"}\"\n].join(\"\\n\");\nfunction generateIfTestSrc(maxIfs) {\n  let src = \"\";\n  for (let i = 0; i < maxIfs; ++i) {\n    if (i > 0) {\n      src += \"\\nelse \";\n    }\n    if (i < maxIfs - 1) {\n      src += `if(test == ${i}.0){}`;\n    }\n  }\n  return src;\n}\nfunction checkMaxIfStatementsInShader(maxIfs, gl) {\n  if (maxIfs === 0) {\n    throw new Error(\"Invalid value of `0` passed to `checkMaxIfStatementsInShader`\");\n  }\n  const shader = gl.createShader(gl.FRAGMENT_SHADER);\n  try {\n    while (true) {\n      const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n      gl.shaderSource(shader, fragmentSrc);\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        maxIfs = maxIfs / 2 | 0;\n      } else {\n        break;\n      }\n    }\n  } finally {\n    gl.deleteShader(shader);\n  }\n  return maxIfs;\n}\n\nexport { checkMaxIfStatementsInShader };\n\n", "import { getTestContext } from '../../../renderers/gl/shader/program/getTestContext.mjs';\nimport { checkMaxIfStatementsInShader } from './checkMaxIfStatementsInShader.mjs';\n\n\"use strict\";\nlet maxTexturesPerBatchCache = null;\nfunction getMaxTexturesPerBatch() {\n  if (maxTexturesPerBatchCache) return maxTexturesPerBatchCache;\n  const gl = getTestContext();\n  maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  maxTexturesPerBatchCache = checkMaxIfStatementsInShader(\n    maxTexturesPerBatchCache,\n    gl\n  );\n  gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n  return maxTexturesPerBatchCache;\n}\n\nexport { getMaxTexturesPerBatch };\n\n", "\"use strict\";\nclass BatchTextureArray {\n  constructor() {\n    /** Respective locations for textures. */\n    this.ids = /* @__PURE__ */ Object.create(null);\n    this.textures = [];\n    this.count = 0;\n  }\n  /** Clear the textures and their locations. */\n  clear() {\n    for (let i = 0; i < this.count; i++) {\n      const t = this.textures[i];\n      this.textures[i] = null;\n      this.ids[t.uid] = null;\n    }\n    this.count = 0;\n  }\n}\n\nexport { BatchTextureArray };\n\n", "import { uid } from '../../../utils/data/uid.mjs';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer.mjs';\nimport { deprecation } from '../../../utils/logging/deprecation.mjs';\nimport { GlobalResourceRegistry } from '../../../utils/pool/GlobalResourceRegistry.mjs';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy.mjs';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures.mjs';\nimport { BatchTextureArray } from './BatchTextureArray.mjs';\n\n\"use strict\";\nclass Batch {\n  constructor() {\n    this.renderPipeId = \"batch\";\n    this.action = \"startBatch\";\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n    // for drawing..\n    this.start = 0;\n    this.size = 0;\n    this.textures = new BatchTextureArray();\n    this.blendMode = \"normal\";\n    this.topology = \"triangle-strip\";\n    this.canBundle = true;\n  }\n  destroy() {\n    this.textures = null;\n    this.gpuBindGroup = null;\n    this.bindGroup = null;\n    this.batcher = null;\n    this.elements = null;\n  }\n}\nconst batchPool = [];\nlet batchPoolIndex = 0;\nGlobalResourceRegistry.register({\n  clear: () => {\n    if (batchPool.length > 0) {\n      for (const item of batchPool) {\n        if (item) item.destroy();\n      }\n    }\n    batchPool.length = 0;\n    batchPoolIndex = 0;\n  }\n});\nfunction getBatchFromPool() {\n  return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\nfunction returnBatchToPool(batch) {\n  batch.elements = null;\n  batchPool[batchPoolIndex++] = batch;\n}\nlet BATCH_TICK = 0;\nconst _Batcher = class _Batcher {\n  constructor(options) {\n    /** unique id for this batcher */\n    this.uid = uid(\"batcher\");\n    /** Indicates whether the batch data has been modified and needs updating. */\n    this.dirty = true;\n    /** The current index of the batch being processed. */\n    this.batchIndex = 0;\n    /** An array of all batches created during the current rendering process. */\n    this.batches = [];\n    this._elements = [];\n    options = { ..._Batcher.defaultOptions, ...options };\n    if (!options.maxTextures) {\n      deprecation(\"v8.8.0\", \"maxTextures is a required option for Batcher now, please pass it in the options\");\n      options.maxTextures = getMaxTexturesPerBatch();\n    }\n    const { maxTextures, attributesInitialSize, indicesInitialSize } = options;\n    this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);\n    this.indexBuffer = new Uint16Array(indicesInitialSize);\n    this.maxTextures = maxTextures;\n  }\n  begin() {\n    this.elementSize = 0;\n    this.elementStart = 0;\n    this.indexSize = 0;\n    this.attributeSize = 0;\n    for (let i = 0; i < this.batchIndex; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batchIndex = 0;\n    this._batchIndexStart = 0;\n    this._batchIndexSize = 0;\n    this.dirty = true;\n  }\n  add(batchableObject) {\n    this._elements[this.elementSize++] = batchableObject;\n    batchableObject._indexStart = this.indexSize;\n    batchableObject._attributeStart = this.attributeSize;\n    batchableObject._batcher = this;\n    this.indexSize += batchableObject.indexSize;\n    this.attributeSize += batchableObject.attributeSize * this.vertexSize;\n  }\n  checkAndUpdateTexture(batchableObject, texture) {\n    const textureId = batchableObject._batch.textures.ids[texture._source.uid];\n    if (!textureId && textureId !== 0) return false;\n    batchableObject._textureId = textureId;\n    batchableObject.texture = texture;\n    return true;\n  }\n  updateElement(batchableObject) {\n    this.dirty = true;\n    const attributeBuffer = this.attributeBuffer;\n    if (batchableObject.packAsQuad) {\n      this.packQuadAttributes(\n        batchableObject,\n        attributeBuffer.float32View,\n        attributeBuffer.uint32View,\n        batchableObject._attributeStart,\n        batchableObject._textureId\n      );\n    } else {\n      this.packAttributes(\n        batchableObject,\n        attributeBuffer.float32View,\n        attributeBuffer.uint32View,\n        batchableObject._attributeStart,\n        batchableObject._textureId\n      );\n    }\n  }\n  /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */\n  break(instructionSet) {\n    const elements = this._elements;\n    if (!elements[this.elementStart]) return;\n    let batch = getBatchFromPool();\n    let textureBatch = batch.textures;\n    textureBatch.clear();\n    const firstElement = elements[this.elementStart];\n    let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n    let topology = firstElement.topology;\n    if (this.attributeSize * 4 > this.attributeBuffer.size) {\n      this._resizeAttributeBuffer(this.attributeSize * 4);\n    }\n    if (this.indexSize > this.indexBuffer.length) {\n      this._resizeIndexBuffer(this.indexSize);\n    }\n    const f32 = this.attributeBuffer.float32View;\n    const u32 = this.attributeBuffer.uint32View;\n    const indexBuffer = this.indexBuffer;\n    let size = this._batchIndexSize;\n    let start = this._batchIndexStart;\n    let action = \"startBatch\";\n    let batchElements = [];\n    const maxTextures = this.maxTextures;\n    for (let i = this.elementStart; i < this.elementSize; ++i) {\n      const element = elements[i];\n      elements[i] = null;\n      const texture = element.texture;\n      const source = texture._source;\n      const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n      const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;\n      if (source._batchTick === BATCH_TICK && !breakRequired) {\n        element._textureId = source._textureBindLocation;\n        size += element.indexSize;\n        if (element.packAsQuad) {\n          this.packQuadAttributes(\n            element,\n            f32,\n            u32,\n            element._attributeStart,\n            element._textureId\n          );\n          this.packQuadIndex(\n            indexBuffer,\n            element._indexStart,\n            element._attributeStart / this.vertexSize\n          );\n        } else {\n          this.packAttributes(\n            element,\n            f32,\n            u32,\n            element._attributeStart,\n            element._textureId\n          );\n          this.packIndex(\n            element,\n            indexBuffer,\n            element._indexStart,\n            element._attributeStart / this.vertexSize\n          );\n        }\n        element._batch = batch;\n        batchElements.push(element);\n        continue;\n      }\n      source._batchTick = BATCH_TICK;\n      if (textureBatch.count >= maxTextures || breakRequired) {\n        this._finishBatch(\n          batch,\n          start,\n          size - start,\n          textureBatch,\n          blendMode,\n          topology,\n          instructionSet,\n          action,\n          batchElements\n        );\n        action = \"renderBatch\";\n        start = size;\n        blendMode = adjustedBlendMode;\n        topology = element.topology;\n        batch = getBatchFromPool();\n        textureBatch = batch.textures;\n        textureBatch.clear();\n        batchElements = [];\n        ++BATCH_TICK;\n      }\n      element._textureId = source._textureBindLocation = textureBatch.count;\n      textureBatch.ids[source.uid] = textureBatch.count;\n      textureBatch.textures[textureBatch.count++] = source;\n      element._batch = batch;\n      batchElements.push(element);\n      size += element.indexSize;\n      if (element.packAsQuad) {\n        this.packQuadAttributes(\n          element,\n          f32,\n          u32,\n          element._attributeStart,\n          element._textureId\n        );\n        this.packQuadIndex(\n          indexBuffer,\n          element._indexStart,\n          element._attributeStart / this.vertexSize\n        );\n      } else {\n        this.packAttributes(\n          element,\n          f32,\n          u32,\n          element._attributeStart,\n          element._textureId\n        );\n        this.packIndex(\n          element,\n          indexBuffer,\n          element._indexStart,\n          element._attributeStart / this.vertexSize\n        );\n      }\n    }\n    if (textureBatch.count > 0) {\n      this._finishBatch(\n        batch,\n        start,\n        size - start,\n        textureBatch,\n        blendMode,\n        topology,\n        instructionSet,\n        action,\n        batchElements\n      );\n      start = size;\n      ++BATCH_TICK;\n    }\n    this.elementStart = this.elementSize;\n    this._batchIndexStart = start;\n    this._batchIndexSize = size;\n  }\n  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, topology, instructionSet, action, elements) {\n    batch.gpuBindGroup = null;\n    batch.bindGroup = null;\n    batch.action = action;\n    batch.batcher = this;\n    batch.textures = textureBatch;\n    batch.blendMode = blendMode;\n    batch.topology = topology;\n    batch.start = indexStart;\n    batch.size = indexSize;\n    batch.elements = elements;\n    ++BATCH_TICK;\n    this.batches[this.batchIndex++] = batch;\n    instructionSet.add(batch);\n  }\n  finish(instructionSet) {\n    this.break(instructionSet);\n  }\n  /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureAttributeBuffer(size) {\n    if (size * 4 <= this.attributeBuffer.size) return;\n    this._resizeAttributeBuffer(size * 4);\n  }\n  /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureIndexBuffer(size) {\n    if (size <= this.indexBuffer.length) return;\n    this._resizeIndexBuffer(size);\n  }\n  _resizeAttributeBuffer(size) {\n    const newSize = Math.max(size, this.attributeBuffer.size * 2);\n    const newArrayBuffer = new ViewableBuffer(newSize);\n    fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n    this.attributeBuffer = newArrayBuffer;\n  }\n  _resizeIndexBuffer(size) {\n    const indexBuffer = this.indexBuffer;\n    let newSize = Math.max(size, indexBuffer.length * 1.5);\n    newSize += newSize % 2;\n    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {\n      for (let i = 0; i < indexBuffer.length; i++) {\n        newIndexBuffer[i] = indexBuffer[i];\n      }\n    } else {\n      fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n    }\n    this.indexBuffer = newIndexBuffer;\n  }\n  packQuadIndex(indexBuffer, index, indicesOffset) {\n    indexBuffer[index] = indicesOffset + 0;\n    indexBuffer[index + 1] = indicesOffset + 1;\n    indexBuffer[index + 2] = indicesOffset + 2;\n    indexBuffer[index + 3] = indicesOffset + 0;\n    indexBuffer[index + 4] = indicesOffset + 2;\n    indexBuffer[index + 5] = indicesOffset + 3;\n  }\n  packIndex(element, indexBuffer, index, indicesOffset) {\n    const indices = element.indices;\n    const size = element.indexSize;\n    const indexOffset = element.indexOffset;\n    const attributeOffset = element.attributeOffset;\n    for (let i = 0; i < size; i++) {\n      indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;\n    }\n  }\n  /**\n   * Destroys the batch and its resources.\n   * @param options - destruction options\n   * @param options.shader - whether to destroy the associated shader\n   */\n  destroy(options = {}) {\n    if (this.batches === null) return;\n    for (let i = 0; i < this.batchIndex; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batches = null;\n    this.geometry.destroy(true);\n    this.geometry = null;\n    if (options.shader) {\n      this.shader?.destroy();\n      this.shader = null;\n    }\n    for (let i = 0; i < this._elements.length; i++) {\n      if (this._elements[i]) this._elements[i]._batch = null;\n    }\n    this._elements = null;\n    this.indexBuffer = null;\n    this.attributeBuffer.destroy();\n    this.attributeBuffer = null;\n  }\n};\n_Batcher.defaultOptions = {\n  maxTextures: null,\n  attributesInitialSize: 4,\n  indicesInitialSize: 6\n};\nlet Batcher = _Batcher;\n\nexport { Batch, Batcher };\n\n", "import { Buffer } from '../../renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry.mjs';\n\n\"use strict\";\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\nclass BatchGeometry extends Geometry {\n  constructor() {\n    const vertexSize = 6;\n    const attributeBuffer = new Buffer({\n      data: placeHolderBufferData,\n      label: \"attribute-batch-buffer\",\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n      shrinkToFit: false\n    });\n    const indexBuffer = new Buffer({\n      data: placeHolderIndexData,\n      label: \"index-batch-buffer\",\n      usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n      // | BufferUsage.STATIC,\n      shrinkToFit: false\n    });\n    const stride = vertexSize * 4;\n    super({\n      attributes: {\n        aPosition: {\n          buffer: attributeBuffer,\n          format: \"float32x2\",\n          stride,\n          offset: 0\n        },\n        aUV: {\n          buffer: attributeBuffer,\n          format: \"float32x2\",\n          stride,\n          offset: 2 * 4\n        },\n        aColor: {\n          buffer: attributeBuffer,\n          format: \"unorm8x4\",\n          stride,\n          offset: 4 * 4\n        },\n        aTextureIdAndRound: {\n          buffer: attributeBuffer,\n          format: \"uint16x2\",\n          stride,\n          offset: 5 * 4\n        }\n      },\n      indexBuffer\n    });\n  }\n}\n\nexport { BatchGeometry };\n\n", "import { UniformGroup } from '../../shared/shader/UniformGroup.mjs';\n\n\"use strict\";\nconst batchSamplersUniformGroupHash = {};\nfunction getBatchSamplersUniformGroup(maxTextures) {\n  let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];\n  if (batchSamplersUniformGroup) return batchSamplersUniformGroup;\n  const sampleValues = new Int32Array(maxTextures);\n  for (let i = 0; i < maxTextures; i++) {\n    sampleValues[i] = i;\n  }\n  batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({\n    uTextures: { value: sampleValues, type: `i32`, size: maxTextures }\n  }, { isStatic: true });\n  return batchSamplersUniformGroup;\n}\n\nexport { getBatchSamplersUniformGroup };\n\n", "import { compileHighShaderGlProgram, compileHighShaderGpuProgram } from '../../high-shader/compileHighShaderToProgram.mjs';\nimport { colorBitGl, colorBit } from '../../high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBitGl, generateTextureBatchBit } from '../../high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { roundPixelsBitGl, roundPixelsBit } from '../../high-shader/shader-bits/roundPixelsBit.mjs';\nimport { getBatchSamplersUniformGroup } from '../../renderers/gl/shader/getBatchSamplersUniformGroup.mjs';\nimport { Shader } from '../../renderers/shared/shader/Shader.mjs';\n\n\"use strict\";\nclass DefaultShader extends Shader {\n  constructor(maxTextures) {\n    const glProgram = compileHighShaderGlProgram({\n      name: \"batch\",\n      bits: [\n        colorBitGl,\n        generateTextureBatchBitGl(maxTextures),\n        roundPixelsBitGl\n      ]\n    });\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"batch\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(maxTextures),\n        roundPixelsBit\n      ]\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        batchSamplers: getBatchSamplersUniformGroup(maxTextures)\n      }\n    });\n    this.maxTextures = maxTextures;\n  }\n}\n\nexport { DefaultShader };\n\n", "import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Batcher } from './Batcher.mjs';\nimport { BatchGeometry } from './BatchGeometry.mjs';\nimport { DefaultShader } from './DefaultShader.mjs';\n\n\"use strict\";\nlet defaultShader = null;\nconst _DefaultBatcher = class _DefaultBatcher extends Batcher {\n  constructor(options) {\n    super(options);\n    this.geometry = new BatchGeometry();\n    this.name = _DefaultBatcher.extension.name;\n    /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, textureIdAndRound -> total = 6 */\n    this.vertexSize = 6;\n    defaultShader ?? (defaultShader = new DefaultShader(options.maxTextures));\n    this.shader = defaultShader;\n  }\n  /**\n   * Packs the attributes of a DefaultBatchableMeshElement into the provided views.\n   * @param element - The DefaultBatchableMeshElement to pack.\n   * @param float32View - The Float32Array view to pack into.\n   * @param uint32View - The Uint32Array view to pack into.\n   * @param index - The starting index in the views.\n   * @param textureId - The texture ID to use.\n   */\n  packAttributes(element, float32View, uint32View, index, textureId) {\n    const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;\n    const wt = element.transform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const { positions, uvs } = element;\n    const argb = element.color;\n    const offset = element.attributeOffset;\n    const end = offset + element.attributeSize;\n    for (let i = offset; i < end; i++) {\n      const i2 = i * 2;\n      const x = positions[i2];\n      const y = positions[i2 + 1];\n      float32View[index++] = a * x + c * y + tx;\n      float32View[index++] = d * y + b * x + ty;\n      float32View[index++] = uvs[i2];\n      float32View[index++] = uvs[i2 + 1];\n      uint32View[index++] = argb;\n      uint32View[index++] = textureIdAndRound;\n    }\n  }\n  /**\n   * Packs the attributes of a DefaultBatchableQuadElement into the provided views.\n   * @param element - The DefaultBatchableQuadElement to pack.\n   * @param float32View - The Float32Array view to pack into.\n   * @param uint32View - The Uint32Array view to pack into.\n   * @param index - The starting index in the views.\n   * @param textureId - The texture ID to use.\n   */\n  packQuadAttributes(element, float32View, uint32View, index, textureId) {\n    const texture = element.texture;\n    const wt = element.transform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const bounds = element.bounds;\n    const w0 = bounds.maxX;\n    const w1 = bounds.minX;\n    const h0 = bounds.maxY;\n    const h1 = bounds.minY;\n    const uvs = texture.uvs;\n    const argb = element.color;\n    const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;\n    float32View[index + 0] = a * w1 + c * h1 + tx;\n    float32View[index + 1] = d * h1 + b * w1 + ty;\n    float32View[index + 2] = uvs.x0;\n    float32View[index + 3] = uvs.y0;\n    uint32View[index + 4] = argb;\n    uint32View[index + 5] = textureIdAndRound;\n    float32View[index + 6] = a * w0 + c * h1 + tx;\n    float32View[index + 7] = d * h1 + b * w0 + ty;\n    float32View[index + 8] = uvs.x1;\n    float32View[index + 9] = uvs.y1;\n    uint32View[index + 10] = argb;\n    uint32View[index + 11] = textureIdAndRound;\n    float32View[index + 12] = a * w0 + c * h0 + tx;\n    float32View[index + 13] = d * h0 + b * w0 + ty;\n    float32View[index + 14] = uvs.x2;\n    float32View[index + 15] = uvs.y2;\n    uint32View[index + 16] = argb;\n    uint32View[index + 17] = textureIdAndRound;\n    float32View[index + 18] = a * w1 + c * h0 + tx;\n    float32View[index + 19] = d * h0 + b * w1 + ty;\n    float32View[index + 20] = uvs.x3;\n    float32View[index + 21] = uvs.y3;\n    uint32View[index + 22] = argb;\n    uint32View[index + 23] = textureIdAndRound;\n  }\n  /**\n   * Updates the maximum number of textures that can be used in the shader.\n   * @param maxTextures - The maximum number of textures that can be used in the shader.\n   * @internal\n   */\n  _updateMaxTextures(maxTextures) {\n    if (this.shader.maxTextures === maxTextures) return;\n    defaultShader = new DefaultShader(maxTextures);\n    this.shader = defaultShader;\n  }\n  destroy() {\n    this.shader = null;\n    super.destroy();\n  }\n};\n/** @ignore */\n_DefaultBatcher.extension = {\n  type: [\n    ExtensionType.Batcher\n  ],\n  name: \"default\"\n};\nlet DefaultBatcher = _DefaultBatcher;\n\nexport { DefaultBatcher };\n\n", "\"use strict\";\nclass GCManagedHash {\n  constructor(options) {\n    // Exposed directly for GC system access\n    this.items = /* @__PURE__ */ Object.create(null);\n    const { renderer, type, onUnload, priority, name } = options;\n    this._renderer = renderer;\n    renderer.gc.addResourceHash(this, \"items\", type, priority ?? 0);\n    this._onUnload = onUnload;\n    this.name = name;\n  }\n  /**\n   * Add an item to the hash. No-op if already added.\n   * @param item\n   * @returns true if the item was added, false if it was already in the hash\n   */\n  add(item) {\n    if (this.items[item.uid]) return false;\n    this.items[item.uid] = item;\n    item.once(\"unload\", this.remove, this);\n    item._gcLastUsed = this._renderer.gc.now;\n    return true;\n  }\n  remove(item, ...args) {\n    if (!this.items[item.uid]) return;\n    const gpuData = item._gpuData[this._renderer.uid];\n    if (!gpuData) return;\n    this._onUnload?.(item, ...args);\n    gpuData.destroy();\n    item._gpuData[this._renderer.uid] = null;\n    this.items[item.uid] = null;\n  }\n  removeAll(...args) {\n    Object.values(this.items).forEach((item) => item && this.remove(item, ...args));\n  }\n  destroy(...args) {\n    this.removeAll(...args);\n    this.items = /* @__PURE__ */ Object.create(null);\n    this._renderer = null;\n    this._onUnload = null;\n  }\n}\n\nexport { GCManagedHash };\n\n"],
  "mappings": "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",
  "names": ["earcut", "_Batcher", "_DefaultBatcher"]
}
