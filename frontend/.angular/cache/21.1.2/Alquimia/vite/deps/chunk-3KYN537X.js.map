{
  "version": 3,
  "sources": ["../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/canvas/utils/canUseNewCanvasBlendModes.mjs", "../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/canvas/utils/canvasUtils.mjs", "../../../../../../../../node_modules/pixi.js/lib/scene/graphics/canvas/CanvasGraphicsAdaptor.mjs", "../../../../../../../../node_modules/pixi.js/lib/rendering/batcher/canvas/CanvasBatchAdaptor.mjs", "../../../../../../../../node_modules/pixi.js/lib/rendering/mask/color/CanvasColorMaskPipe.mjs", "../../../../../../../../node_modules/pixi.js/lib/scene/graphics/canvas/CanvasGraphicsContextSystem.mjs", "../../../../../../../../node_modules/pixi.js/lib/scene/graphics/canvas/CanvasGraphicsPipe.mjs", "../../../../../../../../node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs", "../../../../../../../../node_modules/pixi.js/lib/scene/graphics/init.mjs", "../../../../../../../../node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs", "../../../../../../../../node_modules/pixi.js/lib/rendering/mask/stencil/CanvasStencilMaskPipe.mjs", "../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/canvas/utils/mapCanvasBlendModesToPixi.mjs", "../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/canvas/CanvasContextSystem.mjs", "../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/canvas/CanvasLimitsSystem.mjs", "../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/canvas/renderTarget/CanvasRenderTargetAdaptor.mjs", "../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/canvas/renderTarget/CanvasRenderTargetSystem.mjs", "../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/canvas/texture/CanvasTextureSystem.mjs", "../../../../../../../../node_modules/pixi.js/lib/rendering/renderers/canvas/CanvasRenderer.mjs"],
  "sourcesContent": ["import { DOMAdapter } from '../../../../environment/adapter.mjs';\n\n\"use strict\";\nlet canUseNewCanvasBlendModesValue;\nfunction createColoredCanvas(color) {\n  const canvas = DOMAdapter.get().createCanvas(6, 1);\n  const context = canvas.getContext(\"2d\");\n  context.fillStyle = color;\n  context.fillRect(0, 0, 6, 1);\n  return canvas;\n}\nfunction canUseNewCanvasBlendModes() {\n  if (canUseNewCanvasBlendModesValue !== void 0) {\n    return canUseNewCanvasBlendModesValue;\n  }\n  try {\n    const magenta = createColoredCanvas(\"#ff00ff\");\n    const yellow = createColoredCanvas(\"#ffff00\");\n    const canvas = DOMAdapter.get().createCanvas(6, 1);\n    const context = canvas.getContext(\"2d\");\n    context.globalCompositeOperation = \"multiply\";\n    context.drawImage(magenta, 0, 0);\n    context.drawImage(yellow, 2, 0);\n    const imageData = context.getImageData(2, 0, 1, 1);\n    if (!imageData) {\n      canUseNewCanvasBlendModesValue = false;\n    } else {\n      const data = imageData.data;\n      canUseNewCanvasBlendModesValue = data[0] === 255 && data[1] === 0 && data[2] === 0;\n    }\n  } catch (_error) {\n    canUseNewCanvasBlendModesValue = false;\n  }\n  return canUseNewCanvasBlendModesValue;\n}\n\nexport { canUseNewCanvasBlendModes };\n\n", "import { Color } from '../../../../color/Color.mjs';\nimport { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { groupD8 } from '../../../../maths/matrix/groupD8.mjs';\nimport { canUseNewCanvasBlendModes } from './canUseNewCanvasBlendModes.mjs';\n\n\"use strict\";\nconst canvasUtils = {\n  canvas: null,\n  convertTintToImage: false,\n  cacheStepsPerColorChannel: 8,\n  canUseMultiply: canUseNewCanvasBlendModes(),\n  tintMethod: null,\n  _canvasSourceCache: /* @__PURE__ */ new WeakMap(),\n  _unpremultipliedCache: /* @__PURE__ */ new WeakMap(),\n  getCanvasSource: (texture) => {\n    const source = texture.source;\n    const resource = source?.resource;\n    if (!resource) {\n      return null;\n    }\n    const isPMA = source.alphaMode === \"premultiplied-alpha\";\n    const resourceWidth = source.resourceWidth ?? source.pixelWidth;\n    const resourceHeight = source.resourceHeight ?? source.pixelHeight;\n    const needsResize = resourceWidth !== source.pixelWidth || resourceHeight !== source.pixelHeight;\n    if (isPMA) {\n      if (resource instanceof HTMLCanvasElement || typeof OffscreenCanvas !== \"undefined\" && resource instanceof OffscreenCanvas) {\n        if (!needsResize) {\n          return resource;\n        }\n      }\n      const cached = canvasUtils._unpremultipliedCache.get(source);\n      if (cached?.resourceId === source._resourceId) {\n        return cached.canvas;\n      }\n    }\n    if (resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int8Array || resource instanceof Uint16Array || resource instanceof Int16Array || resource instanceof Uint32Array || resource instanceof Int32Array || resource instanceof Float32Array || resource instanceof ArrayBuffer) {\n      const cached = canvasUtils._canvasSourceCache.get(source);\n      if (cached?.resourceId === source._resourceId) {\n        return cached.canvas;\n      }\n      const canvas = DOMAdapter.get().createCanvas(source.pixelWidth, source.pixelHeight);\n      const context = canvas.getContext(\"2d\");\n      const imageData = context.createImageData(source.pixelWidth, source.pixelHeight);\n      const data = imageData.data;\n      const bytes = resource instanceof ArrayBuffer ? new Uint8Array(resource) : new Uint8Array(resource.buffer, resource.byteOffset, resource.byteLength);\n      if (source.format === \"bgra8unorm\") {\n        for (let i = 0; i < data.length && i + 3 < bytes.length; i += 4) {\n          data[i] = bytes[i + 2];\n          data[i + 1] = bytes[i + 1];\n          data[i + 2] = bytes[i];\n          data[i + 3] = bytes[i + 3];\n        }\n      } else {\n        data.set(bytes.subarray(0, data.length));\n      }\n      context.putImageData(imageData, 0, 0);\n      canvasUtils._canvasSourceCache.set(source, { canvas, resourceId: source._resourceId });\n      return canvas;\n    }\n    if (isPMA) {\n      const canvas = DOMAdapter.get().createCanvas(source.pixelWidth, source.pixelHeight);\n      const context = canvas.getContext(\"2d\", { willReadFrequently: true });\n      canvas.width = source.pixelWidth;\n      canvas.height = source.pixelHeight;\n      context.drawImage(resource, 0, 0);\n      const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n      const data = imageData.data;\n      for (let i = 0; i < data.length; i += 4) {\n        const a = data[i + 3];\n        if (a > 0) {\n          const alphaInv = 255 / a;\n          data[i] = Math.min(255, data[i] * alphaInv + 0.5);\n          data[i + 1] = Math.min(255, data[i + 1] * alphaInv + 0.5);\n          data[i + 2] = Math.min(255, data[i + 2] * alphaInv + 0.5);\n        }\n      }\n      context.putImageData(imageData, 0, 0);\n      canvasUtils._unpremultipliedCache.set(source, { canvas, resourceId: source._resourceId });\n      return canvas;\n    }\n    if (needsResize) {\n      const cached = canvasUtils._canvasSourceCache.get(source);\n      if (cached?.resourceId === source._resourceId) {\n        return cached.canvas;\n      }\n      const canvas = DOMAdapter.get().createCanvas(source.pixelWidth, source.pixelHeight);\n      const context = canvas.getContext(\"2d\");\n      canvas.width = source.pixelWidth;\n      canvas.height = source.pixelHeight;\n      context.drawImage(resource, 0, 0);\n      canvasUtils._canvasSourceCache.set(source, { canvas, resourceId: source._resourceId });\n      return canvas;\n    }\n    return resource;\n  },\n  getTintedCanvas: (sprite, color) => {\n    const texture = sprite.texture;\n    const stringColor = Color.shared.setValue(color).toHex();\n    const cache = texture.tintCache || (texture.tintCache = {});\n    const cachedCanvas = cache[stringColor];\n    const resourceId = texture.source._resourceId;\n    if (cachedCanvas?.tintId === resourceId) {\n      return cachedCanvas;\n    }\n    const canvas = cachedCanvas && \"getContext\" in cachedCanvas ? cachedCanvas : DOMAdapter.get().createCanvas();\n    canvasUtils.tintMethod(texture, color, canvas);\n    canvas.tintId = resourceId;\n    if (canvasUtils.convertTintToImage && canvas.toDataURL !== void 0) {\n      const tintImage = DOMAdapter.get().createImage();\n      tintImage.src = canvas.toDataURL();\n      tintImage.tintId = resourceId;\n      cache[stringColor] = tintImage;\n    } else {\n      cache[stringColor] = canvas;\n    }\n    return cache[stringColor];\n  },\n  getTintedPattern: (texture, color) => {\n    const stringColor = Color.shared.setValue(color).toHex();\n    const cache = texture.patternCache || (texture.patternCache = {});\n    const resourceId = texture.source._resourceId;\n    let pattern = cache[stringColor];\n    if (pattern?.tintId === resourceId) {\n      return pattern;\n    }\n    if (!canvasUtils.canvas) {\n      canvasUtils.canvas = DOMAdapter.get().createCanvas();\n    }\n    canvasUtils.tintMethod(texture, color, canvasUtils.canvas);\n    const context = canvasUtils.canvas.getContext(\"2d\");\n    pattern = context.createPattern(canvasUtils.canvas, \"repeat\");\n    pattern.tintId = resourceId;\n    cache[stringColor] = pattern;\n    return pattern;\n  },\n  /**\n   * Applies a transform to a CanvasPattern.\n   * @param pattern - The pattern to apply the transform to.\n   * @param matrix - The matrix to apply.\n   * @param matrix.a\n   * @param matrix.b\n   * @param matrix.c\n   * @param matrix.d\n   * @param matrix.tx\n   * @param matrix.ty\n   * @param invert\n   */\n  applyPatternTransform: (pattern, matrix, invert = true) => {\n    if (!matrix) return;\n    const patternAny = pattern;\n    if (!patternAny.setTransform) return;\n    const DOMMatrixCtor = globalThis.DOMMatrix;\n    if (!DOMMatrixCtor) return;\n    const domMatrix = new DOMMatrixCtor([matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty]);\n    patternAny.setTransform(invert ? domMatrix.inverse() : domMatrix);\n  },\n  tintWithMultiply: (texture, color, canvas) => {\n    const context = canvas.getContext(\"2d\");\n    const crop = texture.frame.clone();\n    const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;\n    const rotate = texture.rotate;\n    crop.x *= resolution;\n    crop.y *= resolution;\n    crop.width *= resolution;\n    crop.height *= resolution;\n    const isVertical = groupD8.isVertical(rotate);\n    const outWidth = isVertical ? crop.height : crop.width;\n    const outHeight = isVertical ? crop.width : crop.height;\n    canvas.width = Math.ceil(outWidth);\n    canvas.height = Math.ceil(outHeight);\n    context.save();\n    context.fillStyle = Color.shared.setValue(color).toHex();\n    context.fillRect(0, 0, outWidth, outHeight);\n    context.globalCompositeOperation = \"multiply\";\n    const source = canvasUtils.getCanvasSource(texture);\n    if (!source) {\n      context.restore();\n      return;\n    }\n    if (rotate) {\n      canvasUtils._applyInverseRotation(context, rotate, crop.width, crop.height);\n    }\n    context.drawImage(\n      source,\n      crop.x,\n      crop.y,\n      crop.width,\n      crop.height,\n      0,\n      0,\n      crop.width,\n      crop.height\n    );\n    context.globalCompositeOperation = \"destination-atop\";\n    context.drawImage(\n      source,\n      crop.x,\n      crop.y,\n      crop.width,\n      crop.height,\n      0,\n      0,\n      crop.width,\n      crop.height\n    );\n    context.restore();\n  },\n  tintWithOverlay: (texture, color, canvas) => {\n    const context = canvas.getContext(\"2d\");\n    const crop = texture.frame.clone();\n    const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;\n    const rotate = texture.rotate;\n    crop.x *= resolution;\n    crop.y *= resolution;\n    crop.width *= resolution;\n    crop.height *= resolution;\n    const isVertical = groupD8.isVertical(rotate);\n    const outWidth = isVertical ? crop.height : crop.width;\n    const outHeight = isVertical ? crop.width : crop.height;\n    canvas.width = Math.ceil(outWidth);\n    canvas.height = Math.ceil(outHeight);\n    context.save();\n    context.globalCompositeOperation = \"copy\";\n    context.fillStyle = Color.shared.setValue(color).toHex();\n    context.fillRect(0, 0, outWidth, outHeight);\n    context.globalCompositeOperation = \"destination-atop\";\n    const source = canvasUtils.getCanvasSource(texture);\n    if (!source) {\n      context.restore();\n      return;\n    }\n    if (rotate) {\n      canvasUtils._applyInverseRotation(context, rotate, crop.width, crop.height);\n    }\n    context.drawImage(\n      source,\n      crop.x,\n      crop.y,\n      crop.width,\n      crop.height,\n      0,\n      0,\n      crop.width,\n      crop.height\n    );\n    context.restore();\n  },\n  tintWithPerPixel: (texture, color, canvas) => {\n    const context = canvas.getContext(\"2d\");\n    const crop = texture.frame.clone();\n    const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;\n    const rotate = texture.rotate;\n    crop.x *= resolution;\n    crop.y *= resolution;\n    crop.width *= resolution;\n    crop.height *= resolution;\n    const isVertical = groupD8.isVertical(rotate);\n    const outWidth = isVertical ? crop.height : crop.width;\n    const outHeight = isVertical ? crop.width : crop.height;\n    canvas.width = Math.ceil(outWidth);\n    canvas.height = Math.ceil(outHeight);\n    context.save();\n    context.globalCompositeOperation = \"copy\";\n    const source = canvasUtils.getCanvasSource(texture);\n    if (!source) {\n      context.restore();\n      return;\n    }\n    if (rotate) {\n      canvasUtils._applyInverseRotation(context, rotate, crop.width, crop.height);\n    }\n    context.drawImage(\n      source,\n      crop.x,\n      crop.y,\n      crop.width,\n      crop.height,\n      0,\n      0,\n      crop.width,\n      crop.height\n    );\n    context.restore();\n    const r = color >> 16 & 255;\n    const g = color >> 8 & 255;\n    const b = color & 255;\n    const imageData = context.getImageData(0, 0, outWidth, outHeight);\n    const data = imageData.data;\n    for (let i = 0; i < data.length; i += 4) {\n      data[i] = data[i] * r / 255;\n      data[i + 1] = data[i + 1] * g / 255;\n      data[i + 2] = data[i + 2] * b / 255;\n    }\n    context.putImageData(imageData, 0, 0);\n  },\n  /**\n   * Applies inverse rotation transform to context for texture packer rotation compensation.\n   * Supports all 16 groupD8 symmetries (rotations and reflections).\n   * @param context - Canvas 2D context\n   * @param rotate - The groupD8 rotation value\n   * @param srcWidth - Source crop width (before rotation)\n   * @param srcHeight - Source crop height (before rotation)\n   */\n  _applyInverseRotation: (context, rotate, srcWidth, srcHeight) => {\n    const inv = groupD8.inv(rotate);\n    const a = groupD8.uX(inv);\n    const b = groupD8.uY(inv);\n    const c = groupD8.vX(inv);\n    const d = groupD8.vY(inv);\n    const tx = -Math.min(0, a * srcWidth, c * srcHeight, a * srcWidth + c * srcHeight);\n    const ty = -Math.min(0, b * srcWidth, d * srcHeight, b * srcWidth + d * srcHeight);\n    context.transform(a, b, c, d, tx, ty);\n  }\n};\ncanvasUtils.tintMethod = canvasUtils.canUseMultiply ? canvasUtils.tintWithMultiply : canvasUtils.tintWithPerPixel;\n\nexport { canvasUtils };\n\n", "import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { groupD8 } from '../../../maths/matrix/groupD8.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { canvasUtils } from '../../../rendering/renderers/canvas/utils/canvasUtils.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { bgr2rgb } from '../../container/container-mixins/getGlobalMixin.mjs';\nimport { multiplyHexColors } from '../../container/utils/multiplyHexColors.mjs';\nimport { buildLine } from '../shared/buildCommands/buildLine.mjs';\nimport { FillGradient } from '../shared/fill/FillGradient.mjs';\nimport { FillPattern } from '../shared/fill/FillPattern.mjs';\nimport { shapeBuilders } from '../shared/utils/buildContextBatches.mjs';\nimport { generateTextureMatrix } from '../shared/utils/generateTextureFillMatrix.mjs';\n\n\"use strict\";\nconst emptyCanvasStyle = \"#808080\";\nconst tempMatrix = new Matrix();\nconst tempTextureMatrix = new Matrix();\nconst tempGradientMatrix = new Matrix();\nconst tempPatternMatrix = new Matrix();\nfunction fillTriangles(context, vertices, indices) {\n  context.beginPath();\n  for (let i = 0; i < indices.length; i += 3) {\n    const i0 = indices[i] * 2;\n    const i1 = indices[i + 1] * 2;\n    const i2 = indices[i + 2] * 2;\n    context.moveTo(vertices[i0], vertices[i0 + 1]);\n    context.lineTo(vertices[i1], vertices[i1 + 1]);\n    context.lineTo(vertices[i2], vertices[i2 + 1]);\n    context.closePath();\n  }\n  context.fill();\n}\nfunction colorToHex(color) {\n  const clamped = color & 16777215;\n  return `#${clamped.toString(16).padStart(6, \"0\")}`;\n}\nfunction buildRoundedRectPath(context, x, y, width, height, radius) {\n  radius = Math.max(0, Math.min(radius, Math.min(width, height) / 2));\n  context.moveTo(x + radius, y);\n  context.lineTo(x + width - radius, y);\n  context.quadraticCurveTo(x + width, y, x + width, y + radius);\n  context.lineTo(x + width, y + height - radius);\n  context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n  context.lineTo(x + radius, y + height);\n  context.quadraticCurveTo(x, y + height, x, y + height - radius);\n  context.lineTo(x, y + radius);\n  context.quadraticCurveTo(x, y, x + radius, y);\n}\nfunction buildShapePath(context, shape) {\n  switch (shape.type) {\n    case \"rectangle\": {\n      const rect = shape;\n      context.rect(rect.x, rect.y, rect.width, rect.height);\n      break;\n    }\n    case \"roundedRectangle\": {\n      const rect = shape;\n      buildRoundedRectPath(context, rect.x, rect.y, rect.width, rect.height, rect.radius);\n      break;\n    }\n    case \"circle\": {\n      const circle = shape;\n      context.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);\n      break;\n    }\n    case \"ellipse\": {\n      const ellipse = shape;\n      if (context.ellipse) {\n        context.ellipse(ellipse.x, ellipse.y, ellipse.halfWidth, ellipse.halfHeight, 0, 0, Math.PI * 2);\n      } else {\n        context.save();\n        context.translate(ellipse.x, ellipse.y);\n        context.scale(ellipse.halfWidth, ellipse.halfHeight);\n        context.arc(0, 0, 1, 0, Math.PI * 2);\n        context.restore();\n      }\n      break;\n    }\n    case \"triangle\": {\n      const tri = shape;\n      context.moveTo(tri.x, tri.y);\n      context.lineTo(tri.x2, tri.y2);\n      context.lineTo(tri.x3, tri.y3);\n      context.closePath();\n      break;\n    }\n    case \"polygon\":\n    default: {\n      const poly = shape;\n      const points = poly.points;\n      if (!points?.length) break;\n      context.moveTo(points[0], points[1]);\n      for (let i = 2; i < points.length; i += 2) {\n        context.lineTo(points[i], points[i + 1]);\n      }\n      if (poly.closePath) {\n        context.closePath();\n      }\n      break;\n    }\n  }\n}\nfunction addHolePaths(context, holes) {\n  if (!holes?.length) return false;\n  for (let i = 0; i < holes.length; i++) {\n    const hole = holes[i];\n    if (!hole?.shape) continue;\n    const transform = hole.transform;\n    const hasTransform = transform && !transform.isIdentity();\n    if (hasTransform) {\n      context.save();\n      context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);\n    }\n    buildShapePath(context, hole.shape);\n    if (hasTransform) {\n      context.restore();\n    }\n  }\n  return true;\n}\nfunction getCanvasStyle(style, tint, textureMatrix, currentTransform) {\n  const fill = style.fill;\n  if (fill instanceof FillGradient) {\n    fill.buildGradient();\n    const gradientTexture = fill.texture;\n    if (gradientTexture) {\n      const pattern = canvasUtils.getTintedPattern(gradientTexture, tint);\n      const patternMatrix = textureMatrix ? tempPatternMatrix.copyFrom(textureMatrix).scale(gradientTexture.source.pixelWidth, gradientTexture.source.pixelHeight) : tempPatternMatrix.copyFrom(fill.transform);\n      if (currentTransform && !style.textureSpace) {\n        patternMatrix.append(currentTransform);\n      }\n      canvasUtils.applyPatternTransform(pattern, patternMatrix);\n      return pattern;\n    }\n  }\n  if (fill instanceof FillPattern) {\n    const pattern = canvasUtils.getTintedPattern(fill.texture, tint);\n    canvasUtils.applyPatternTransform(pattern, fill.transform);\n    return pattern;\n  }\n  const texture = style.texture;\n  if (texture && texture !== Texture.WHITE) {\n    if (!texture.source.resource) {\n      return emptyCanvasStyle;\n    }\n    const pattern = canvasUtils.getTintedPattern(texture, tint);\n    const patternMatrix = textureMatrix ? tempPatternMatrix.copyFrom(textureMatrix).scale(texture.source.pixelWidth, texture.source.pixelHeight) : style.matrix;\n    canvasUtils.applyPatternTransform(pattern, patternMatrix);\n    return pattern;\n  }\n  return colorToHex(tint);\n}\nclass CanvasGraphicsAdaptor {\n  constructor() {\n    this.shader = null;\n  }\n  contextChange(renderer) {\n    void renderer;\n  }\n  execute(graphicsPipe, renderable) {\n    const renderer = graphicsPipe.renderer;\n    const contextSystem = renderer.canvasContext;\n    const context = contextSystem.activeContext;\n    const baseTransform = renderable.groupTransform;\n    const globalColor = renderer.globalUniforms.globalUniformData?.worldColor ?? 4294967295;\n    const groupColorAlpha = renderable.groupColorAlpha;\n    const globalAlpha = (globalColor >>> 24 & 255) / 255;\n    const groupAlphaValue = (groupColorAlpha >>> 24 & 255) / 255;\n    const filterAlpha = renderer.filter?.alphaMultiplier ?? 1;\n    const groupAlpha = globalAlpha * groupAlphaValue * filterAlpha;\n    if (groupAlpha <= 0) return;\n    const globalTint = globalColor & 16777215;\n    const groupTintBGR = groupColorAlpha & 16777215;\n    const groupTint = bgr2rgb(multiplyHexColors(groupTintBGR, globalTint));\n    const roundPixels = renderer._roundPixels | renderable._roundPixels;\n    context.save();\n    contextSystem.setContextTransform(baseTransform, roundPixels === 1);\n    contextSystem.setBlendMode(renderable.groupBlendMode);\n    const instructions = renderable.context.instructions;\n    for (let i = 0; i < instructions.length; i++) {\n      const instruction = instructions[i];\n      if (instruction.action === \"texture\") {\n        const data2 = instruction.data;\n        const texture = data2.image;\n        const source = texture ? canvasUtils.getCanvasSource(texture) : null;\n        if (!source) continue;\n        const alpha2 = data2.alpha * groupAlpha;\n        if (alpha2 <= 0) continue;\n        const tint2 = multiplyHexColors(data2.style, groupTint);\n        context.globalAlpha = alpha2;\n        let drawSource = source;\n        if (tint2 !== 16777215) {\n          drawSource = canvasUtils.getTintedCanvas({ texture }, tint2);\n        }\n        const frame = texture.frame;\n        const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;\n        let sx = frame.x * resolution;\n        let sy = frame.y * resolution;\n        const sw = frame.width * resolution;\n        const sh = frame.height * resolution;\n        if (drawSource !== source) {\n          sx = 0;\n          sy = 0;\n        }\n        const transform = data2.transform;\n        const hasTransform = transform && !transform.isIdentity();\n        const rotate = texture.rotate;\n        if (hasTransform || rotate) {\n          tempMatrix.copyFrom(baseTransform);\n          if (hasTransform) {\n            tempMatrix.append(transform);\n          }\n          if (rotate) {\n            groupD8.matrixAppendRotationInv(tempMatrix, rotate, data2.dx, data2.dy, data2.dw, data2.dh);\n          }\n          contextSystem.setContextTransform(tempMatrix, roundPixels === 1);\n        } else {\n          contextSystem.setContextTransform(baseTransform, roundPixels === 1);\n        }\n        context.drawImage(\n          drawSource,\n          sx,\n          sy,\n          drawSource === source ? sw : drawSource.width,\n          drawSource === source ? sh : drawSource.height,\n          rotate ? 0 : data2.dx,\n          rotate ? 0 : data2.dy,\n          data2.dw,\n          data2.dh\n        );\n        if (hasTransform || rotate) {\n          contextSystem.setContextTransform(baseTransform, roundPixels === 1);\n        }\n        continue;\n      }\n      const data = instruction.data;\n      const shapePath = data?.path?.shapePath;\n      if (!shapePath?.shapePrimitives?.length) continue;\n      const style = data.style;\n      const tint = multiplyHexColors(style.color, groupTint);\n      const alpha = style.alpha * groupAlpha;\n      if (alpha <= 0) continue;\n      const isStroke = instruction.action === \"stroke\";\n      context.globalAlpha = alpha;\n      if (isStroke) {\n        const strokeStyle = style;\n        context.lineWidth = strokeStyle.width;\n        context.lineCap = strokeStyle.cap;\n        context.lineJoin = strokeStyle.join;\n        context.miterLimit = strokeStyle.miterLimit;\n      }\n      const shapePrimitives = shapePath.shapePrimitives;\n      if (!isStroke && data.hole?.shapePath?.shapePrimitives?.length) {\n        const lastShape = shapePrimitives[shapePrimitives.length - 1];\n        lastShape.holes = data.hole.shapePath.shapePrimitives;\n      }\n      for (let j = 0; j < shapePrimitives.length; j++) {\n        const primitive = shapePrimitives[j];\n        if (!primitive?.shape) continue;\n        const transform = primitive.transform;\n        const hasTransform = transform && !transform.isIdentity();\n        const hasTexture = style.texture && style.texture !== Texture.WHITE;\n        const textureTransform = style.textureSpace === \"global\" ? transform : null;\n        const textureMatrix = hasTexture ? generateTextureMatrix(tempTextureMatrix, style, primitive.shape, textureTransform) : null;\n        const currentTransform = hasTransform ? tempGradientMatrix.copyFrom(baseTransform).append(transform) : baseTransform;\n        const canvasStyle = getCanvasStyle(\n          style,\n          tint,\n          textureMatrix,\n          currentTransform\n        );\n        if (hasTransform) {\n          context.save();\n          context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);\n        }\n        if (isStroke) {\n          const strokeStyle = style;\n          const useStrokeGeometry = strokeStyle.alignment !== 0.5 && !strokeStyle.pixelLine;\n          if (useStrokeGeometry) {\n            const points = [];\n            const vertices = [];\n            const indices = [];\n            const shapeBuilder = shapeBuilders[primitive.shape.type];\n            if (shapeBuilder?.build(primitive.shape, points)) {\n              const close = primitive.shape.closePath ?? true;\n              buildLine(points, strokeStyle, false, close, vertices, indices);\n              context.fillStyle = canvasStyle;\n              fillTriangles(context, vertices, indices);\n            } else {\n              context.strokeStyle = canvasStyle;\n              context.beginPath();\n              buildShapePath(context, primitive.shape);\n              context.stroke();\n            }\n          } else {\n            context.strokeStyle = canvasStyle;\n            context.beginPath();\n            buildShapePath(context, primitive.shape);\n            context.stroke();\n          }\n        } else {\n          context.fillStyle = canvasStyle;\n          context.beginPath();\n          buildShapePath(context, primitive.shape);\n          const hasHoles = addHolePaths(context, primitive.holes);\n          if (hasHoles) {\n            context.fill(\"evenodd\");\n          } else {\n            context.fill();\n          }\n        }\n        if (hasTransform) {\n          context.restore();\n        }\n      }\n    }\n    context.restore();\n  }\n  destroy() {\n    this.shader = null;\n  }\n}\n/** @ignore */\nCanvasGraphicsAdaptor.extension = {\n  type: [\n    ExtensionType.CanvasPipesAdaptor\n  ],\n  name: \"graphics\"\n};\n\nexport { CanvasGraphicsAdaptor };\n\n", "import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { groupD8 } from '../../../maths/matrix/groupD8.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { bgr2rgb } from '../../../scene/container/container-mixins/getGlobalMixin.mjs';\nimport { multiplyHexColors } from '../../../scene/container/utils/multiplyHexColors.mjs';\nimport { canvasUtils } from '../../renderers/canvas/utils/canvasUtils.mjs';\n\n\"use strict\";\nconst _CanvasBatchAdaptor = class _CanvasBatchAdaptor {\n  static _getPatternRepeat(addressModeU, addressModeV) {\n    const repeatU = addressModeU && addressModeU !== \"clamp-to-edge\";\n    const repeatV = addressModeV && addressModeV !== \"clamp-to-edge\";\n    if (repeatU && repeatV) return \"repeat\";\n    if (repeatU) return \"repeat-x\";\n    if (repeatV) return \"repeat-y\";\n    return \"no-repeat\";\n  }\n  start(batchPipe, geometry, shader) {\n    void batchPipe;\n    void geometry;\n    void shader;\n  }\n  execute(batchPipe, batch) {\n    const elements = batch.elements;\n    if (!elements || !elements.length) return;\n    const renderer = batchPipe.renderer;\n    const contextSystem = renderer.canvasContext;\n    const context = contextSystem.activeContext;\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      if (!element.packAsQuad) continue;\n      const quad = element;\n      const texture = quad.texture;\n      const source = texture ? canvasUtils.getCanvasSource(texture) : null;\n      if (!source) continue;\n      const textureStyle = texture.source.style;\n      const smoothProperty = contextSystem.smoothProperty;\n      const shouldSmooth = textureStyle.scaleMode !== \"nearest\";\n      if (context[smoothProperty] !== shouldSmooth) {\n        context[smoothProperty] = shouldSmooth;\n      }\n      contextSystem.setBlendMode(batch.blendMode);\n      const globalColor = renderer.globalUniforms.globalUniformData?.worldColor ?? 4294967295;\n      const argb = quad.color;\n      const globalAlpha = (globalColor >>> 24 & 255) / 255;\n      const quadAlpha = (argb >>> 24 & 255) / 255;\n      const filterAlpha = renderer.filter?.alphaMultiplier ?? 1;\n      const alpha = globalAlpha * quadAlpha * filterAlpha;\n      if (alpha <= 0) continue;\n      context.globalAlpha = alpha;\n      const globalTint = globalColor & 16777215;\n      const quadTint = argb & 16777215;\n      const tint = bgr2rgb(multiplyHexColors(quadTint, globalTint));\n      const frame = texture.frame;\n      const repeatU = textureStyle.addressModeU ?? textureStyle.addressMode;\n      const repeatV = textureStyle.addressModeV ?? textureStyle.addressMode;\n      const repeat = _CanvasBatchAdaptor._getPatternRepeat(repeatU, repeatV);\n      const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;\n      const isFromCachedRenderGroup = quad.renderable?.renderGroup?.isCachedAsTexture;\n      const sx = frame.x * resolution;\n      const sy = frame.y * resolution;\n      const sw = frame.width * resolution;\n      const sh = frame.height * resolution;\n      const bounds = quad.bounds;\n      const isRootTarget = renderer.renderTarget.renderTarget.isRoot;\n      const dx = bounds.minX;\n      const dy = bounds.minY;\n      const dw = bounds.maxX - bounds.minX;\n      const dh = bounds.maxY - bounds.minY;\n      const rotate = texture.rotate;\n      const uvs = texture.uvs;\n      const uvMin = Math.min(uvs.x0, uvs.x1, uvs.x2, uvs.x3, uvs.y0, uvs.y1, uvs.y2, uvs.y3);\n      const uvMax = Math.max(uvs.x0, uvs.x1, uvs.x2, uvs.x3, uvs.y0, uvs.y1, uvs.y2, uvs.y3);\n      const needsRepeat = repeat !== \"no-repeat\" && (uvMin < 0 || uvMax > 1);\n      const willUseProcessedCanvas = !needsRepeat && (tint !== 16777215 || rotate);\n      const applyRotateTransform = rotate && !willUseProcessedCanvas;\n      if (applyRotateTransform) {\n        _CanvasBatchAdaptor._tempPatternMatrix.copyFrom(quad.transform);\n        groupD8.matrixAppendRotationInv(\n          _CanvasBatchAdaptor._tempPatternMatrix,\n          rotate,\n          dx,\n          dy,\n          dw,\n          dh\n        );\n        contextSystem.setContextTransform(\n          _CanvasBatchAdaptor._tempPatternMatrix,\n          quad.roundPixels === 1,\n          void 0,\n          isFromCachedRenderGroup && isRootTarget\n        );\n      } else {\n        contextSystem.setContextTransform(\n          quad.transform,\n          quad.roundPixels === 1,\n          void 0,\n          isFromCachedRenderGroup && isRootTarget\n        );\n      }\n      const drawX = applyRotateTransform ? 0 : dx;\n      const drawY = applyRotateTransform ? 0 : dy;\n      const drawW = dw;\n      const drawH = dh;\n      if (needsRepeat) {\n        let patternSource = source;\n        const canTint = tint !== 16777215 && !rotate;\n        const fitsFrame = frame.width <= texture.source.width && frame.height <= texture.source.height;\n        if (canTint && fitsFrame) {\n          patternSource = canvasUtils.getTintedCanvas({ texture }, tint);\n        }\n        const pattern = context.createPattern(patternSource, repeat);\n        if (!pattern) continue;\n        const denomX = drawW;\n        const denomY = drawH;\n        if (denomX === 0 || denomY === 0) continue;\n        const invDx = 1 / denomX;\n        const invDy = 1 / denomY;\n        const a = (uvs.x1 - uvs.x0) * invDx;\n        const b = (uvs.y1 - uvs.y0) * invDx;\n        const c = (uvs.x3 - uvs.x0) * invDy;\n        const d = (uvs.y3 - uvs.y0) * invDy;\n        const tx = uvs.x0 - a * drawX - c * drawY;\n        const ty = uvs.y0 - b * drawX - d * drawY;\n        const pixelWidth = texture.source.pixelWidth;\n        const pixelHeight = texture.source.pixelHeight;\n        _CanvasBatchAdaptor._tempPatternMatrix.set(\n          a * pixelWidth,\n          b * pixelHeight,\n          c * pixelWidth,\n          d * pixelHeight,\n          tx * pixelWidth,\n          ty * pixelHeight\n        );\n        canvasUtils.applyPatternTransform(pattern, _CanvasBatchAdaptor._tempPatternMatrix);\n        context.fillStyle = pattern;\n        context.fillRect(drawX, drawY, drawW, drawH);\n      } else {\n        const needsProcessing = tint !== 16777215 || rotate;\n        const processedSource = needsProcessing ? canvasUtils.getTintedCanvas({ texture }, tint) : source;\n        const isProcessed = processedSource !== source;\n        context.drawImage(\n          processedSource,\n          isProcessed ? 0 : sx,\n          isProcessed ? 0 : sy,\n          isProcessed ? processedSource.width : sw,\n          isProcessed ? processedSource.height : sh,\n          drawX,\n          drawY,\n          drawW,\n          drawH\n        );\n      }\n    }\n  }\n};\n_CanvasBatchAdaptor._tempPatternMatrix = new Matrix();\n/** @ignore */\n_CanvasBatchAdaptor.extension = {\n  type: [\n    ExtensionType.CanvasPipesAdaptor\n  ],\n  name: \"batch\"\n};\nlet CanvasBatchAdaptor = _CanvasBatchAdaptor;\n\nexport { CanvasBatchAdaptor };\n\n", "import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass CanvasColorMaskPipe {\n  constructor(renderer) {\n    this._colorStack = [];\n    this._colorStackIndex = 0;\n    this._currentColor = 0;\n    this._renderer = renderer;\n  }\n  buildStart() {\n    this._colorStack[0] = 15;\n    this._colorStackIndex = 1;\n    this._currentColor = 15;\n  }\n  push(mask, _container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;\n    const currentColor = this._colorStack[this._colorStackIndex];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n    this._colorStackIndex++;\n  }\n  pop(_mask, _container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    this._colorStackIndex--;\n    const currentColor = colorStack[this._colorStackIndex - 1];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n  }\n  execute(_instruction) {\n  }\n  destroy() {\n    this._renderer = null;\n    this._colorStack = null;\n  }\n}\n/** @ignore */\nCanvasColorMaskPipe.extension = {\n  type: [\n    ExtensionType.CanvasPipes\n  ],\n  name: \"colorMask\"\n};\n\nexport { CanvasColorMaskPipe };\n\n", "import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet.mjs';\nimport { GCManagedHash } from '../../../utils/data/GCManagedHash.mjs';\n\n\"use strict\";\nclass CanvasGraphicsContext {\n  constructor() {\n    /**\n     * Whether this context can be batched.\n     * @advanced\n     */\n    this.isBatchable = false;\n  }\n  /**\n   * Reset cached canvas data.\n   * @advanced\n   */\n  reset() {\n    this.isBatchable = false;\n    this.context = null;\n    if (this.graphicsData) {\n      this.graphicsData.destroy();\n      this.graphicsData = null;\n    }\n  }\n  /**\n   * Destroy the cached data.\n   * @advanced\n   */\n  destroy() {\n    this.reset();\n  }\n}\nclass CanvasGraphicsContextRenderData {\n  constructor() {\n    /**\n     * Instructions for canvas rendering.\n     * @advanced\n     */\n    this.instructions = new InstructionSet();\n  }\n  /**\n   * Initialize render data.\n   * @advanced\n   */\n  init() {\n    this.instructions.reset();\n  }\n  /**\n   * Destroy render data.\n   * @advanced\n   */\n  destroy() {\n    this.instructions.destroy();\n    this.instructions = null;\n  }\n}\nconst _CanvasGraphicsContextSystem = class _CanvasGraphicsContextSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._managedContexts = new GCManagedHash({ renderer, type: \"resource\", name: \"graphicsContext\" });\n  }\n  /**\n   * Runner init called, update the default options\n   * @ignore\n   */\n  init(options) {\n    _CanvasGraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _CanvasGraphicsContextSystem.defaultOptions.bezierSmoothness;\n  }\n  /**\n   * Returns the render data for a given GraphicsContext.\n   * @param context - The GraphicsContext to get the render data for.\n   * @internal\n   */\n  getContextRenderData(context) {\n    const gpuContext = this.getGpuContext(context);\n    return gpuContext.graphicsData || this._initContextRenderData(context);\n  }\n  /**\n   * Updates the GPU context for a given GraphicsContext.\n   * @param context - The GraphicsContext to update.\n   * @returns The updated CanvasGraphicsContext.\n   * @internal\n   */\n  updateGpuContext(context) {\n    const gpuData = context._gpuData;\n    const hasContext = !!gpuData[this._renderer.uid];\n    const gpuContext = gpuData[this._renderer.uid] || this._initContext(context);\n    if (context.dirty || !hasContext) {\n      if (hasContext) {\n        gpuContext.reset();\n      }\n      gpuContext.isBatchable = false;\n      context.dirty = false;\n    }\n    return gpuContext;\n  }\n  /**\n   * Returns the CanvasGraphicsContext for a given GraphicsContext.\n   * If it does not exist, it will initialize a new one.\n   * @param context - The GraphicsContext to get the CanvasGraphicsContext for.\n   * @returns The CanvasGraphicsContext for the given GraphicsContext.\n   * @internal\n   */\n  getGpuContext(context) {\n    const gpuData = context._gpuData;\n    return gpuData[this._renderer.uid] || this._initContext(context);\n  }\n  _initContextRenderData(context) {\n    const renderData = new CanvasGraphicsContextRenderData();\n    const gpuContext = this.getGpuContext(context);\n    gpuContext.graphicsData = renderData;\n    renderData.init();\n    return renderData;\n  }\n  _initContext(context) {\n    const gpuContext = new CanvasGraphicsContext();\n    gpuContext.context = context;\n    context._gpuData[this._renderer.uid] = gpuContext;\n    this._managedContexts.add(context);\n    return gpuContext;\n  }\n  destroy() {\n    this._managedContexts.destroy();\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_CanvasGraphicsContextSystem.extension = {\n  type: [\n    ExtensionType.CanvasSystem\n  ],\n  name: \"graphicsContext\"\n};\n/** The default options for the GraphicsContextSystem. */\n_CanvasGraphicsContextSystem.defaultOptions = {\n  /**\n   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n   * @default 0.5\n   */\n  bezierSmoothness: 0.5\n};\nlet CanvasGraphicsContextSystem = _CanvasGraphicsContextSystem;\n\nexport { CanvasGraphicsContextSystem };\n\n", "import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../../rendering/renderers/shared/state/State.mjs';\nimport { GCManagedHash } from '../../../utils/data/GCManagedHash.mjs';\n\n\"use strict\";\nclass CanvasGraphicsPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.for2d();\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this.renderer.runners.contextChange.add(this);\n    this._managedGraphics = new GCManagedHash({ renderer, type: \"renderable\", priority: -1, name: \"graphics\" });\n  }\n  contextChange() {\n    this._adaptor.contextChange(this.renderer);\n  }\n  validateRenderable(_graphics) {\n    return false;\n  }\n  addRenderable(graphics, instructionSet) {\n    this._managedGraphics.add(graphics);\n    this.renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(graphics);\n  }\n  updateRenderable(_graphics) {\n  }\n  execute(graphics) {\n    if (!graphics.isRenderable) return;\n    this._adaptor.execute(this, graphics);\n  }\n  destroy() {\n    this._managedGraphics.destroy();\n    this.renderer = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n  }\n}\n/** @ignore */\nCanvasGraphicsPipe.extension = {\n  type: [\n    ExtensionType.CanvasPipes\n  ],\n  name: \"graphics\"\n};\n\nexport { CanvasGraphicsPipe };\n\n", "import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../../rendering/renderers/shared/state/State.mjs';\nimport { GCManagedHash } from '../../../utils/data/GCManagedHash.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { color32BitToUniform } from '../gpu/colorToUniform.mjs';\nimport { BatchableGraphics } from './BatchableGraphics.mjs';\n\n\"use strict\";\nclass GraphicsGpuData {\n  constructor() {\n    this.batches = [];\n    this.batched = false;\n  }\n  destroy() {\n    this.batches.forEach((batch) => {\n      BigPool.return(batch);\n    });\n    this.batches.length = 0;\n  }\n}\nclass GraphicsPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.for2d();\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this.renderer.runners.contextChange.add(this);\n    this._managedGraphics = new GCManagedHash({ renderer, type: \"renderable\", priority: -1, name: \"graphics\" });\n  }\n  contextChange() {\n    this._adaptor.contextChange(this.renderer);\n  }\n  validateRenderable(graphics) {\n    const context = graphics.context;\n    const wasBatched = !!graphics._gpuData;\n    const contextSystem = this.renderer.graphicsContext;\n    const gpuContext = contextSystem.updateGpuContext(context);\n    if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(graphics, instructionSet) {\n    const contextSystem = this.renderer.graphicsContext;\n    const gpuContext = contextSystem.updateGpuContext(graphics.context);\n    if (graphics.didViewUpdate) {\n      this._rebuild(graphics);\n    }\n    if (gpuContext.isBatchable) {\n      this._addToBatcher(graphics, instructionSet);\n    } else {\n      this.renderer.renderPipes.batch.break(instructionSet);\n      instructionSet.add(graphics);\n    }\n  }\n  updateRenderable(graphics) {\n    const gpuData = this._getGpuDataForRenderable(graphics);\n    const batches = gpuData.batches;\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batch._batcher.updateElement(batch);\n    }\n  }\n  execute(graphics) {\n    if (!graphics.isRenderable) return;\n    const renderer = this.renderer;\n    const context = graphics.context;\n    const contextSystem = renderer.graphicsContext;\n    if (!contextSystem.getGpuContext(context).batches.length) {\n      return;\n    }\n    const shader = context.customShader || this._adaptor.shader;\n    this.state.blendMode = graphics.groupBlendMode;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = graphics.groupTransform;\n    localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n    color32BitToUniform(\n      graphics.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, graphics);\n  }\n  _rebuild(graphics) {\n    const gpuData = this._getGpuDataForRenderable(graphics);\n    const contextSystem = this.renderer.graphicsContext;\n    const gpuContext = contextSystem.updateGpuContext(graphics.context);\n    gpuData.destroy();\n    if (gpuContext.isBatchable) {\n      this._updateBatchesForRenderable(graphics, gpuData);\n    }\n  }\n  _addToBatcher(graphics, instructionSet) {\n    const batchPipe = this.renderer.renderPipes.batch;\n    const batches = this._getGpuDataForRenderable(graphics).batches;\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batchPipe.addToBatch(batch, instructionSet);\n    }\n  }\n  _getGpuDataForRenderable(graphics) {\n    return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);\n  }\n  _initGpuDataForRenderable(graphics) {\n    const gpuData = new GraphicsGpuData();\n    graphics._gpuData[this.renderer.uid] = gpuData;\n    this._managedGraphics.add(graphics);\n    return gpuData;\n  }\n  _updateBatchesForRenderable(graphics, gpuData) {\n    const context = graphics.context;\n    const contextSystem = this.renderer.graphicsContext;\n    const gpuContext = contextSystem.getGpuContext(context);\n    const roundPixels = this.renderer._roundPixels | graphics._roundPixels;\n    gpuData.batches = gpuContext.batches.map((batch) => {\n      const batchClone = BigPool.get(BatchableGraphics);\n      batch.copyTo(batchClone);\n      batchClone.renderable = graphics;\n      batchClone.roundPixels = roundPixels;\n      return batchClone;\n    });\n  }\n  destroy() {\n    this._managedGraphics.destroy();\n    this.renderer = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.state = null;\n  }\n}\n/** @ignore */\nGraphicsPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes\n  ],\n  name: \"graphics\"\n};\n\nexport { GraphicsGpuData, GraphicsPipe };\n\n", "import { extensions } from '../../extensions/Extensions.mjs';\nimport { CanvasGraphicsContextSystem } from './canvas/CanvasGraphicsContextSystem.mjs';\nimport { CanvasGraphicsPipe } from './canvas/CanvasGraphicsPipe.mjs';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem.mjs';\nimport { GraphicsPipe } from './shared/GraphicsPipe.mjs';\n\n\"use strict\";\nextensions.add(CanvasGraphicsPipe);\nextensions.add(GraphicsPipe);\nextensions.add(CanvasGraphicsContextSystem);\nextensions.add(GraphicsContextSystem);\n\n", "import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { ViewContainer } from '../../view/ViewContainer.mjs';\nimport { GraphicsContext } from './GraphicsContext.mjs';\nimport '../init.mjs';\n\n\"use strict\";\nclass Graphics extends ViewContainer {\n  /**\n   * Creates a new Graphics object.\n   * @param options - Options for the Graphics.\n   */\n  constructor(options) {\n    if (options instanceof GraphicsContext) {\n      options = { context: options };\n    }\n    const { context, roundPixels, ...rest } = options || {};\n    super({\n      label: \"Graphics\",\n      ...rest\n    });\n    /** @internal */\n    this.renderPipeId = \"graphics\";\n    if (!context) {\n      this.context = this._ownedContext = new GraphicsContext();\n      this.context.autoGarbageCollect = this.autoGarbageCollect;\n    } else {\n      this.context = context;\n    }\n    this.didViewUpdate = true;\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n  }\n  set context(context) {\n    if (context === this._context) return;\n    if (this._context) {\n      this._context.off(\"update\", this.onViewUpdate, this);\n      this._context.off(\"unload\", this.unload, this);\n    }\n    this._context = context;\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this._context.on(\"unload\", this.unload, this);\n    this.onViewUpdate();\n  }\n  /**\n   * The underlying graphics context used for drawing operations.\n   * Controls how shapes and paths are rendered.\n   * @example\n   * ```ts\n   * // Create a shared context\n   * const sharedContext = new GraphicsContext();\n   *\n   * // Create graphics objects sharing the same context\n   * const graphics1 = new Graphics();\n   * const graphics2 = new Graphics();\n   *\n   * // Assign shared context\n   * graphics1.context = sharedContext;\n   * graphics2.context = sharedContext;\n   *\n   * // Both graphics will show the same shapes\n   * sharedContext\n   *     .rect(0, 0, 100, 100)\n   *     .fill({ color: 0xff0000 });\n   * ```\n   * @see {@link GraphicsContext} For drawing operations\n   * @see {@link GraphicsOptions} For context configuration\n   */\n  get context() {\n    return this._context;\n  }\n  /**\n   * The local bounds of the graphics object.\n   * Returns the boundaries after all graphical operations but before any transforms.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw a shape\n   * graphics\n   *     .rect(0, 0, 100, 100)\n   *     .fill({ color: 0xff0000 });\n   *\n   * // Get bounds information\n   * const bounds = graphics.bounds;\n   * console.log(bounds.width);  // 100\n   * console.log(bounds.height); // 100\n   * ```\n   * @readonly\n   * @see {@link Bounds} For bounds operations\n   * @see {@link Container#getBounds} For transformed bounds\n   */\n  get bounds() {\n    return this._context.bounds;\n  }\n  /**\n   * Graphics objects do not need to update their bounds as the context handles this.\n   * @private\n   */\n  updateBounds() {\n  }\n  /**\n   * Checks if the object contains the given point.\n   * Returns true if the point lies within the Graphics object's rendered area.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw a shape\n   * graphics\n   *     .rect(0, 0, 100, 100)\n   *     .fill({ color: 0xff0000 });\n   *\n   * // Check point intersection\n   * if (graphics.containsPoint({ x: 50, y: 50 })) {\n   *     console.log('Point is inside rectangle!');\n   * }\n   * ```\n   * @param point - The point to check in local coordinates\n   * @returns True if the point is inside the Graphics object\n   * @see {@link Graphics#bounds} For bounding box checks\n   * @see {@link PointData} For point data structure\n   */\n  containsPoint(point) {\n    return this._context.containsPoint(point);\n  }\n  /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @example\n   * ```ts\n   * // Destroy the graphics and its context\n   * graphics.destroy();\n   * graphics.destroy(true);\n   * graphics.destroy({ context: true, texture: true, textureSource: true });\n   * ```\n   */\n  destroy(options) {\n    if (this._ownedContext && !options) {\n      this._ownedContext.destroy(options);\n    } else if (options === true || options?.context === true) {\n      this._context.destroy(options);\n    }\n    this._ownedContext = null;\n    this._context = null;\n    super.destroy(options);\n  }\n  /**\n   * @param now - The current time in milliseconds.\n   * @internal\n   */\n  _onTouch(now) {\n    this._gcLastUsed = now;\n    this._context._gcLastUsed = now;\n  }\n  _callContextMethod(method, args) {\n    this.context[method](...args);\n    return this;\n  }\n  // --------------------------------------- GraphicsContext methods ---------------------------------------\n  /**\n   * Sets the current fill style of the graphics context.\n   * The fill style can be a color, gradient, pattern, or a complex style object.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic color fill\n   * graphics\n   *     .setFillStyle({ color: 0xff0000 }) // Red fill\n   *     .rect(0, 0, 100, 100)\n   *     .fill();\n   *\n   * // Gradient fill\n   * const gradient = new FillGradient({\n   *    end: { x: 1, y: 0 },\n   *    colorStops: [\n   *         { offset: 0, color: 0xff0000 }, // Red at start\n   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n   *         { offset: 1, color: 0x0000ff }, // Blue at end\n   *    ],\n   * });\n   *\n   * graphics\n   *     .setFillStyle(gradient)\n   *     .circle(100, 100, 50)\n   *     .fill();\n   *\n   * // Pattern fill\n   * const pattern = new FillPattern(texture);\n   * graphics\n   *     .setFillStyle({\n   *         fill: pattern,\n   *         alpha: 0.5\n   *     })\n   *     .rect(0, 0, 200, 200)\n   *     .fill();\n   * ```\n   * @param {FillInput} args - The fill style to apply\n   * @returns The Graphics instance for chaining\n   * @see {@link FillStyle} For fill style options\n   * @see {@link FillGradient} For gradient fills\n   * @see {@link FillPattern} For pattern fills\n   */\n  setFillStyle(...args) {\n    return this._callContextMethod(\"setFillStyle\", args);\n  }\n  /**\n   * Sets the current stroke style of the graphics context.\n   * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic color stroke\n   * graphics\n   *     .setStrokeStyle({\n   *         width: 2,\n   *         color: 0x000000\n   *     })\n   *     .rect(0, 0, 100, 100)\n   *     .stroke();\n   *\n   * // Complex stroke style\n   * graphics\n   *     .setStrokeStyle({\n   *         width: 4,\n   *         color: 0xff0000,\n   *         alpha: 0.5,\n   *         join: 'round',\n   *         cap: 'round',\n   *         alignment: 0.5\n   *     })\n   *     .circle(100, 100, 50)\n   *     .stroke();\n   *\n   * // Gradient stroke\n   * const gradient = new FillGradient({\n   *    end: { x: 1, y: 0 },\n   *    colorStops: [\n   *         { offset: 0, color: 0xff0000 }, // Red at start\n   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n   *         { offset: 1, color: 0x0000ff }, // Blue at end\n   *    ],\n   * });\n   *\n   * graphics\n   *     .setStrokeStyle({\n   *         width: 10,\n   *         fill: gradient\n   *     })\n   *     .poly([0,0, 100,50, 0,100])\n   *     .stroke();\n   * ```\n   * @param {StrokeInput} args - The stroke style to apply\n   * @returns The Graphics instance for chaining\n   * @see {@link StrokeStyle} For stroke style options\n   * @see {@link FillGradient} For gradient strokes\n   * @see {@link FillPattern} For pattern strokes\n   */\n  setStrokeStyle(...args) {\n    return this._callContextMethod(\"setStrokeStyle\", args);\n  }\n  fill(...args) {\n    return this._callContextMethod(\"fill\", args);\n  }\n  /**\n   * Strokes the current path with the current stroke style or specified style.\n   * Outlines the shape using the stroke settings.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Stroke with direct color\n   * graphics\n   *     .circle(50, 50, 25)\n   *     .stroke({\n   *         width: 2,\n   *         color: 0xff0000\n   *     }); // 2px red stroke\n   *\n   * // Fill with texture\n   * graphics\n   *    .rect(0, 0, 100, 100)\n   *    .stroke(myTexture); // Fill with texture\n   *\n   * // Stroke with gradient\n   * const gradient = new FillGradient({\n   *     end: { x: 1, y: 0 },\n   *     colorStops: [\n   *         { offset: 0, color: 0xff0000 },\n   *         { offset: 0.5, color: 0x00ff00 },\n   *         { offset: 1, color: 0x0000ff },\n   *     ],\n   * });\n   *\n   * graphics\n   *     .rect(0, 0, 100, 100)\n   *     .stroke({\n   *         width: 4,\n   *         fill: gradient,\n   *         alignment: 0.5,\n   *         join: 'round'\n   *     });\n   * ```\n   * @param {StrokeStyle} args - Optional stroke style to apply. Can be:\n   * - A stroke style object with width, color, etc.\n   * - A gradient\n   * - A pattern\n   * If omitted, uses current stroke style.\n   * @returns The Graphics instance for chaining\n   * @see {@link StrokeStyle} For stroke style options\n   * @see {@link FillGradient} For gradient strokes\n   * @see {@link setStrokeStyle} For setting default stroke style\n   */\n  stroke(...args) {\n    return this._callContextMethod(\"stroke\", args);\n  }\n  texture(...args) {\n    return this._callContextMethod(\"texture\", args);\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   * graphics\n   *     .circle(150, 150, 50)\n   *     .fill({ color: 0x00ff00 })\n   *     .beginPath() // Starts a new path\n   *     .circle(250, 150, 50)\n   *     .fill({ color: 0x0000ff });\n   * ```\n   * @returns The Graphics instance for chaining\n   * @see {@link Graphics#moveTo} For starting a new subpath\n   * @see {@link Graphics#closePath} For closing the current path\n   */\n  beginPath() {\n    return this._callContextMethod(\"beginPath\", []);\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path.\n   *\n   * If a hole is not completely in a shape, it will fail to cut correctly.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw outer circle\n   * graphics\n   *     .circle(100, 100, 50)\n   *     .fill({ color: 0xff0000 });\n   *     .circle(100, 100, 25) // Inner circle\n   *     .cut() // Cuts out the inner circle from the outer circle\n   * ```\n   */\n  cut() {\n    return this._callContextMethod(\"cut\", []);\n  }\n  arc(...args) {\n    return this._callContextMethod(\"arc\", args);\n  }\n  arcTo(...args) {\n    return this._callContextMethod(\"arcTo\", args);\n  }\n  arcToSvg(...args) {\n    return this._callContextMethod(\"arcToSvg\", args);\n  }\n  bezierCurveTo(...args) {\n    return this._callContextMethod(\"bezierCurveTo\", args);\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start point.\n   *\n   * This is useful for completing shapes and ensuring they are properly closed for fills.\n   * @example\n   * ```ts\n   * // Create a triangle with closed path\n   * const graphics = new Graphics();\n   * graphics\n   *     .moveTo(50, 50)\n   *     .lineTo(100, 100)\n   *     .lineTo(0, 100)\n   *     .closePath()\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#beginPath} For starting a new path\n   * @see {@link Graphics#fill} For filling closed paths\n   * @see {@link Graphics#stroke} For stroking paths\n   */\n  closePath() {\n    return this._callContextMethod(\"closePath\", []);\n  }\n  ellipse(...args) {\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  circle(...args) {\n    return this._callContextMethod(\"circle\", args);\n  }\n  path(...args) {\n    return this._callContextMethod(\"path\", args);\n  }\n  lineTo(...args) {\n    return this._callContextMethod(\"lineTo\", args);\n  }\n  moveTo(...args) {\n    return this._callContextMethod(\"moveTo\", args);\n  }\n  quadraticCurveTo(...args) {\n    return this._callContextMethod(\"quadraticCurveTo\", args);\n  }\n  rect(...args) {\n    return this._callContextMethod(\"rect\", args);\n  }\n  roundRect(...args) {\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  poly(...args) {\n    return this._callContextMethod(\"poly\", args);\n  }\n  regularPoly(...args) {\n    return this._callContextMethod(\"regularPoly\", args);\n  }\n  roundPoly(...args) {\n    return this._callContextMethod(\"roundPoly\", args);\n  }\n  roundShape(...args) {\n    return this._callContextMethod(\"roundShape\", args);\n  }\n  filletRect(...args) {\n    return this._callContextMethod(\"filletRect\", args);\n  }\n  chamferRect(...args) {\n    return this._callContextMethod(\"chamferRect\", args);\n  }\n  star(...args) {\n    return this._callContextMethod(\"star\", args);\n  }\n  svg(...args) {\n    return this._callContextMethod(\"svg\", args);\n  }\n  restore(...args) {\n    return this._callContextMethod(\"restore\", args);\n  }\n  /**\n   * Saves the current graphics state onto a stack. The state includes:\n   * - Current transformation matrix\n   * - Current fill style\n   * - Current stroke style\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Save state before complex operations\n   * graphics.save();\n   *\n   * // Create transformed and styled shape\n   * graphics\n   *     .translateTransform(100, 100)\n   *     .rotateTransform(Math.PI / 4)\n   *     .setFillStyle({\n   *         color: 0xff0000,\n   *         alpha: 0.5\n   *     })\n   *     .rect(-25, -25, 50, 50)\n   *     .fill();\n   *\n   * // Restore to original state\n   * graphics.restore();\n   *\n   * // Continue drawing with previous state\n   * graphics\n   *     .circle(50, 50, 25)\n   *     .fill();\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#restore} For restoring the saved state\n   * @see {@link Graphics#setTransform} For setting transformations\n   */\n  save() {\n    return this._callContextMethod(\"save\", []);\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * This matrix represents all accumulated transformations including translate, scale, and rotate.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Apply some transformations\n   * graphics\n   *     .translateTransform(100, 100)\n   *     .rotateTransform(Math.PI / 4);\n   *\n   * // Get the current transform matrix\n   * const matrix = graphics.getTransform();\n   * console.log(matrix.tx, matrix.ty); // 100, 100\n   *\n   * // Use the matrix for other operations\n   * graphics\n   *     .setTransform(matrix)\n   *     .circle(0, 0, 50)\n   *     .fill({ color: 0xff0000 });\n   * ```\n   * @returns The current transformation matrix.\n   * @see {@link Graphics#setTransform} For setting the transform matrix\n   * @see {@link Matrix} For matrix operations\n   */\n  getTransform() {\n    return this.context.getTransform();\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Apply transformations\n   * graphics\n   *     .translateTransform(100, 100)\n   *     .scaleTransform(2, 2)\n   *     .circle(0, 0, 25)\n   *     .fill({ color: 0xff0000 });\n   * // Reset transform to default state\n   * graphics\n   *     .resetTransform()\n   *     .circle(50, 50, 25) // Will draw at actual coordinates\n   *     .fill({ color: 0x00ff00 });\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#getTransform} For getting the current transform\n   * @see {@link Graphics#setTransform} For setting a specific transform\n   * @see {@link Graphics#save} For saving the current transform state\n   * @see {@link Graphics#restore} For restoring a previous transform state\n   */\n  resetTransform() {\n    return this._callContextMethod(\"resetTransform\", []);\n  }\n  rotateTransform(...args) {\n    return this._callContextMethod(\"rotate\", args);\n  }\n  scaleTransform(...args) {\n    return this._callContextMethod(\"scale\", args);\n  }\n  setTransform(...args) {\n    return this._callContextMethod(\"setTransform\", args);\n  }\n  transform(...args) {\n    return this._callContextMethod(\"transform\", args);\n  }\n  translateTransform(...args) {\n    return this._callContextMethod(\"translate\", args);\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it.\n   * This includes clearing the current path, fill style, stroke style, and transformations.\n   *\n   * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.\n   * > Instead, they are intended to be used for static or semi-static graphics that\n   * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw some shapes\n   * graphics\n   *     .circle(100, 100, 50)\n   *     .fill({ color: 0xff0000 })\n   *     .rect(200, 100, 100, 50)\n   *     .fill({ color: 0x00ff00 });\n   *\n   * // Clear all graphics\n   * graphics.clear();\n   *\n   * // Start fresh with new shapes\n   * graphics\n   *     .circle(150, 150, 30)\n   *     .fill({ color: 0x0000ff });\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#beginPath} For starting a new path without clearing styles\n   * @see {@link Graphics#save} For saving the current state\n   * @see {@link Graphics#restore} For restoring a previous state\n   */\n  clear() {\n    return this._callContextMethod(\"clear\", []);\n  }\n  /**\n   * Gets or sets the current fill style for the graphics context. The fill style determines\n   * how shapes are filled when using the fill() method.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic color fill\n   * graphics.fillStyle = {\n   *     color: 0xff0000,  // Red\n   *     alpha: 1\n   * };\n   *\n   * // Using gradients\n   * const gradient = new FillGradient({\n   *     end: { x: 0, y: 1 }, // Vertical gradient\n   *     stops: [\n   *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color\n   *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color\n   *     ]\n   * });\n   *\n   * graphics.fillStyle = {\n   *     fill: gradient,\n   *     alpha: 0.8\n   * };\n   *\n   * // Using patterns\n   * graphics.fillStyle = {\n   *     texture: myTexture,\n   *     alpha: 1,\n   *     matrix: new Matrix()\n   *         .scale(0.5, 0.5)\n   *         .rotate(Math.PI / 4)\n   * };\n   * ```\n   * @type {ConvertedFillStyle}\n   * @see {@link FillStyle} For all available fill style options\n   * @see {@link FillGradient} For creating gradient fills\n   * @see {@link Graphics#fill} For applying the fill to paths\n   */\n  get fillStyle() {\n    return this._context.fillStyle;\n  }\n  set fillStyle(value) {\n    this._context.fillStyle = value;\n  }\n  /**\n   * Gets or sets the current stroke style for the graphics context. The stroke style determines\n   * how paths are outlined when using the stroke() method.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic stroke style\n   * graphics.strokeStyle = {\n   *     width: 2,\n   *     color: 0xff0000,\n   *     alpha: 1\n   * };\n   *\n   * // Using with gradients\n   * const gradient = new FillGradient({\n   *   end: { x: 0, y: 1 },\n   *   stops: [\n   *       { offset: 0, color: 0xff0000, alpha: 1 },\n   *       { offset: 1, color: 0x0000ff, alpha: 1 }\n   *   ]\n   * });\n   *\n   * graphics.strokeStyle = {\n   *     width: 4,\n   *     fill: gradient,\n   *     alignment: 0.5,\n   *     join: 'round',\n   *     cap: 'round'\n   * };\n   *\n   * // Complex stroke settings\n   * graphics.strokeStyle = {\n   *     width: 6,\n   *     color: 0x00ff00,\n   *     alpha: 0.5,\n   *     join: 'miter',\n   *     miterLimit: 10,\n   * };\n   * ```\n   * @see {@link StrokeStyle} For all available stroke style options\n   * @see {@link Graphics#stroke} For applying the stroke to paths\n   */\n  get strokeStyle() {\n    return this._context.strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._context.strokeStyle = value;\n  }\n  /**\n   * Creates a new Graphics object that copies the current graphics content.\n   * The clone can either share the same context (shallow clone) or have its own independent\n   * context (deep clone).\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Create original graphics content\n   * graphics\n   *     .circle(100, 100, 50)\n   *     .fill({ color: 0xff0000 });\n   *\n   * // Create a shallow clone (shared context)\n   * const shallowClone = graphics.clone();\n   *\n   * // Changes to original affect the clone\n   * graphics\n   *     .circle(200, 100, 30)\n   *     .fill({ color: 0x00ff00 });\n   *\n   * // Create a deep clone (independent context)\n   * const deepClone = graphics.clone(true);\n   *\n   * // Modify deep clone independently\n   * deepClone\n   *     .translateTransform(100, 100)\n   *     .circle(0, 0, 40)\n   *     .fill({ color: 0x0000ff });\n   * ```\n   * @param deep - Whether to create a deep clone of the graphics object.\n   *              If false (default), the context will be shared between objects.\n   *              If true, creates an independent copy of the context.\n   * @returns A new Graphics instance with either shared or copied context\n   * @see {@link Graphics#context} For accessing the underlying graphics context\n   * @see {@link GraphicsContext} For understanding the shared context behavior\n   */\n  clone(deep = false) {\n    if (deep) {\n      return new Graphics(this._context.clone());\n    }\n    this._ownedContext = null;\n    const clone = new Graphics(this._context);\n    return clone;\n  }\n  // -------- v7 deprecations ---------\n  /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */\n  lineStyle(width, color, alpha) {\n    deprecation(v8_0_0, \"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.\");\n    const strokeStyle = {};\n    width && (strokeStyle.width = width);\n    color && (strokeStyle.color = color);\n    alpha && (strokeStyle.alpha = alpha);\n    this.context.strokeStyle = strokeStyle;\n    return this;\n  }\n  /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  beginFill(color, alpha) {\n    deprecation(v8_0_0, \"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    const fillStyle = {};\n    if (color !== void 0) fillStyle.color = color;\n    if (alpha !== void 0) fillStyle.alpha = alpha;\n    this.context.fillStyle = fillStyle;\n    return this;\n  }\n  /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  endFill() {\n    deprecation(v8_0_0, \"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    this.context.fill();\n    const strokeStyle = this.context.strokeStyle;\n    if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {\n      this.context.stroke();\n    }\n    return this;\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */\n  drawCircle(...args) {\n    deprecation(v8_0_0, \"Graphics#drawCircle has been renamed to Graphics#circle\");\n    return this._callContextMethod(\"circle\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */\n  drawEllipse(...args) {\n    deprecation(v8_0_0, \"Graphics#drawEllipse has been renamed to Graphics#ellipse\");\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */\n  drawPolygon(...args) {\n    deprecation(v8_0_0, \"Graphics#drawPolygon has been renamed to Graphics#poly\");\n    return this._callContextMethod(\"poly\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */\n  drawRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRect has been renamed to Graphics#rect\");\n    return this._callContextMethod(\"rect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */\n  drawRoundedRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRoundedRect has been renamed to Graphics#roundRect\");\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */\n  drawStar(...args) {\n    deprecation(v8_0_0, \"Graphics#drawStar has been renamed to Graphics#star\");\n    return this._callContextMethod(\"star\", args);\n  }\n}\n\nexport { Graphics };\n\n", "import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Graphics } from '../../../scene/graphics/shared/Graphics.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction buildRoundedRectPath(context, x, y, width, height, radius) {\n  radius = Math.max(0, Math.min(radius, Math.min(width, height) / 2));\n  context.moveTo(x + radius, y);\n  context.lineTo(x + width - radius, y);\n  context.quadraticCurveTo(x + width, y, x + width, y + radius);\n  context.lineTo(x + width, y + height - radius);\n  context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n  context.lineTo(x + radius, y + height);\n  context.quadraticCurveTo(x, y + height, x, y + height - radius);\n  context.lineTo(x, y + radius);\n  context.quadraticCurveTo(x, y, x + radius, y);\n}\nfunction buildShapePath(context, shape) {\n  switch (shape.type) {\n    case \"rectangle\": {\n      const rect = shape;\n      context.rect(rect.x, rect.y, rect.width, rect.height);\n      break;\n    }\n    case \"roundedRectangle\": {\n      const rect = shape;\n      buildRoundedRectPath(context, rect.x, rect.y, rect.width, rect.height, rect.radius);\n      break;\n    }\n    case \"circle\": {\n      const circle = shape;\n      context.moveTo(circle.x + circle.radius, circle.y);\n      context.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);\n      break;\n    }\n    case \"ellipse\": {\n      const ellipse = shape;\n      if (context.ellipse) {\n        context.moveTo(ellipse.x + ellipse.halfWidth, ellipse.y);\n        context.ellipse(ellipse.x, ellipse.y, ellipse.halfWidth, ellipse.halfHeight, 0, 0, Math.PI * 2);\n      } else {\n        context.save();\n        context.translate(ellipse.x, ellipse.y);\n        context.scale(ellipse.halfWidth, ellipse.halfHeight);\n        context.moveTo(1, 0);\n        context.arc(0, 0, 1, 0, Math.PI * 2);\n        context.restore();\n      }\n      break;\n    }\n    case \"triangle\": {\n      const tri = shape;\n      context.moveTo(tri.x, tri.y);\n      context.lineTo(tri.x2, tri.y2);\n      context.lineTo(tri.x3, tri.y3);\n      context.closePath();\n      break;\n    }\n    case \"polygon\":\n    default: {\n      const poly = shape;\n      const points = poly.points;\n      if (!points?.length) break;\n      context.moveTo(points[0], points[1]);\n      for (let i = 2; i < points.length; i += 2) {\n        context.lineTo(points[i], points[i + 1]);\n      }\n      if (poly.closePath) {\n        context.closePath();\n      }\n      break;\n    }\n  }\n}\nfunction addHolePaths(context, holes) {\n  if (!holes?.length) return false;\n  for (let i = 0; i < holes.length; i++) {\n    const hole = holes[i];\n    if (!hole?.shape) continue;\n    const transform = hole.transform;\n    const hasTransform = transform && !transform.isIdentity();\n    if (hasTransform) {\n      context.save();\n      context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);\n    }\n    buildShapePath(context, hole.shape);\n    if (hasTransform) {\n      context.restore();\n    }\n  }\n  return true;\n}\nclass CanvasStencilMaskPipe {\n  constructor(renderer) {\n    this._warnedMaskTypes = /* @__PURE__ */ new Set();\n    this._canvasMaskStack = [];\n    this._renderer = renderer;\n  }\n  push(mask, _container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  pop(_mask, _container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskEnd\",\n      mask: _mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    if (instruction.action !== \"pushMaskBegin\" && instruction.action !== \"popMaskEnd\") {\n      return;\n    }\n    const canvasRenderer = this._renderer;\n    const contextSystem = canvasRenderer.canvasContext;\n    const context = contextSystem?.activeContext;\n    if (!context) return;\n    if (instruction.action === \"popMaskEnd\") {\n      const didClip = this._canvasMaskStack.pop();\n      if (didClip) {\n        context.restore();\n      }\n      return;\n    }\n    if (instruction.inverse) {\n      this._warnOnce(\n        \"inverse\",\n        \"CanvasRenderer: inverse masks are not supported on Canvas2D; ignoring inverse flag.\"\n      );\n    }\n    const maskContainer = instruction.mask.mask;\n    if (!(maskContainer instanceof Graphics)) {\n      this._warnOnce(\n        \"nonGraphics\",\n        \"CanvasRenderer: only Graphics masks are supported in Canvas2D; skipping mask.\"\n      );\n      this._canvasMaskStack.push(false);\n      return;\n    }\n    const graphics = maskContainer;\n    const instructions = graphics.context?.instructions;\n    if (!instructions?.length) {\n      this._canvasMaskStack.push(false);\n      return;\n    }\n    context.save();\n    contextSystem.setContextTransform(\n      graphics.groupTransform,\n      (canvasRenderer._roundPixels | graphics._roundPixels) === 1\n    );\n    context.beginPath();\n    let drewPath = false;\n    let hasHoles = false;\n    for (let i = 0; i < instructions.length; i++) {\n      const instructionData = instructions[i];\n      const action = instructionData.action;\n      if (action !== \"fill\" && action !== \"stroke\") continue;\n      const data = instructionData.data;\n      const shapePath = data?.path?.shapePath;\n      if (!shapePath?.shapePrimitives?.length) continue;\n      const shapePrimitives = shapePath.shapePrimitives;\n      for (let j = 0; j < shapePrimitives.length; j++) {\n        const primitive = shapePrimitives[j];\n        if (!primitive?.shape) continue;\n        const transform = primitive.transform;\n        const hasTransform = transform && !transform.isIdentity();\n        if (hasTransform) {\n          context.save();\n          context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);\n        }\n        buildShapePath(context, primitive.shape);\n        hasHoles = addHolePaths(context, primitive.holes) || hasHoles;\n        drewPath = true;\n        if (hasTransform) {\n          context.restore();\n        }\n      }\n    }\n    if (!drewPath) {\n      context.restore();\n      this._canvasMaskStack.push(false);\n      return;\n    }\n    if (hasHoles) {\n      context.clip(\"evenodd\");\n    } else {\n      context.clip();\n    }\n    this._canvasMaskStack.push(true);\n  }\n  destroy() {\n    this._renderer = null;\n    this._warnedMaskTypes = null;\n    this._canvasMaskStack = null;\n  }\n  _warnOnce(key, message) {\n    if (this._warnedMaskTypes.has(key)) return;\n    this._warnedMaskTypes.add(key);\n    warn(message);\n  }\n}\nCanvasStencilMaskPipe.extension = {\n  type: [\n    ExtensionType.CanvasPipes\n  ],\n  name: \"stencilMask\"\n};\n\nexport { CanvasStencilMaskPipe };\n\n", "import { canUseNewCanvasBlendModes } from './canUseNewCanvasBlendModes.mjs';\n\n\"use strict\";\nconst FALLBACK_BLEND = \"source-over\";\nfunction mapCanvasBlendModesToPixi() {\n  const supportsAdvanced = canUseNewCanvasBlendModes();\n  const map = /* @__PURE__ */ Object.create(null);\n  map.inherit = FALLBACK_BLEND;\n  map.none = FALLBACK_BLEND;\n  map.normal = \"source-over\";\n  map.add = \"lighter\";\n  map.multiply = supportsAdvanced ? \"multiply\" : FALLBACK_BLEND;\n  map.screen = supportsAdvanced ? \"screen\" : FALLBACK_BLEND;\n  map.overlay = supportsAdvanced ? \"overlay\" : FALLBACK_BLEND;\n  map.darken = supportsAdvanced ? \"darken\" : FALLBACK_BLEND;\n  map.lighten = supportsAdvanced ? \"lighten\" : FALLBACK_BLEND;\n  map[\"color-dodge\"] = supportsAdvanced ? \"color-dodge\" : FALLBACK_BLEND;\n  map[\"color-burn\"] = supportsAdvanced ? \"color-burn\" : FALLBACK_BLEND;\n  map[\"hard-light\"] = supportsAdvanced ? \"hard-light\" : FALLBACK_BLEND;\n  map[\"soft-light\"] = supportsAdvanced ? \"soft-light\" : FALLBACK_BLEND;\n  map.difference = supportsAdvanced ? \"difference\" : FALLBACK_BLEND;\n  map.exclusion = supportsAdvanced ? \"exclusion\" : FALLBACK_BLEND;\n  map.saturation = supportsAdvanced ? \"saturation\" : FALLBACK_BLEND;\n  map.color = supportsAdvanced ? \"color\" : FALLBACK_BLEND;\n  map.luminosity = supportsAdvanced ? \"luminosity\" : FALLBACK_BLEND;\n  map[\"linear-burn\"] = supportsAdvanced ? \"color-burn\" : FALLBACK_BLEND;\n  map[\"linear-dodge\"] = supportsAdvanced ? \"color-dodge\" : FALLBACK_BLEND;\n  map[\"linear-light\"] = supportsAdvanced ? \"hard-light\" : FALLBACK_BLEND;\n  map[\"pin-light\"] = supportsAdvanced ? \"hard-light\" : FALLBACK_BLEND;\n  map[\"vivid-light\"] = supportsAdvanced ? \"hard-light\" : FALLBACK_BLEND;\n  map[\"hard-mix\"] = FALLBACK_BLEND;\n  map.negation = supportsAdvanced ? \"difference\" : FALLBACK_BLEND;\n  map[\"normal-npm\"] = map.normal;\n  map[\"add-npm\"] = map.add;\n  map[\"screen-npm\"] = map.screen;\n  map.erase = \"destination-out\";\n  map.subtract = FALLBACK_BLEND;\n  map.divide = FALLBACK_BLEND;\n  map.min = FALLBACK_BLEND;\n  map.max = FALLBACK_BLEND;\n  return map;\n}\n\nexport { mapCanvasBlendModesToPixi };\n\n", "import { Color } from '../../../color/Color.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { mapCanvasBlendModesToPixi } from './utils/mapCanvasBlendModesToPixi.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nclass CanvasContextSystem {\n  /**\n   * @param renderer - The owning CanvasRenderer.\n   */\n  constructor(renderer) {\n    /** Resolution of the active context. */\n    this.activeResolution = 1;\n    /** The image smoothing property to toggle for this browser. */\n    this.smoothProperty = \"imageSmoothingEnabled\";\n    /** Map of Pixi blend modes to canvas composite operations. */\n    this.blendModes = mapCanvasBlendModesToPixi();\n    /** Current canvas blend mode. */\n    this._activeBlendMode = \"normal\";\n    /** Optional projection transform for render targets. */\n    this._projTransform = null;\n    /** True when external blend mode control is in use. */\n    this._outerBlend = false;\n    /** Tracks unsupported blend mode warnings to avoid spam. */\n    this._warnedBlendModes = /* @__PURE__ */ new Set();\n    this._renderer = renderer;\n  }\n  resolutionChange(resolution) {\n    this.activeResolution = resolution;\n  }\n  /** Initializes the root context and smoothing flag selection. */\n  init() {\n    const alpha = this._renderer.background.alpha < 1;\n    this.rootContext = this._renderer.canvas.getContext(\n      \"2d\",\n      { alpha }\n    );\n    this.activeContext = this.rootContext;\n    this.activeResolution = this._renderer.resolution;\n    if (!this.rootContext.imageSmoothingEnabled) {\n      const rc = this.rootContext;\n      if (rc.webkitImageSmoothingEnabled) {\n        this.smoothProperty = \"webkitImageSmoothingEnabled\";\n      } else if (rc.mozImageSmoothingEnabled) {\n        this.smoothProperty = \"mozImageSmoothingEnabled\";\n      } else if (rc.oImageSmoothingEnabled) {\n        this.smoothProperty = \"oImageSmoothingEnabled\";\n      } else if (rc.msImageSmoothingEnabled) {\n        this.smoothProperty = \"msImageSmoothingEnabled\";\n      }\n    }\n  }\n  /**\n   * Sets the current transform on the active context.\n   * @param transform - Transform to apply.\n   * @param roundPixels - Whether to round translation to integers.\n   * @param localResolution - Optional local resolution multiplier.\n   * @param skipGlobalTransform - If true, skip applying the global world transform matrix.\n   */\n  setContextTransform(transform, roundPixels, localResolution, skipGlobalTransform) {\n    const globalTransform = skipGlobalTransform ? Matrix.IDENTITY : this._renderer.globalUniforms.globalUniformData?.worldTransformMatrix || Matrix.IDENTITY;\n    let mat = tempMatrix;\n    mat.copyFrom(globalTransform);\n    mat.append(transform);\n    const proj = this._projTransform;\n    const contextResolution = this.activeResolution;\n    localResolution = localResolution || contextResolution;\n    if (proj) {\n      const finalMat = Matrix.shared;\n      finalMat.copyFrom(mat);\n      finalMat.prepend(proj);\n      mat = finalMat;\n    }\n    if (roundPixels) {\n      this.activeContext.setTransform(\n        mat.a * localResolution,\n        mat.b * localResolution,\n        mat.c * localResolution,\n        mat.d * localResolution,\n        mat.tx * contextResolution | 0,\n        mat.ty * contextResolution | 0\n      );\n    } else {\n      this.activeContext.setTransform(\n        mat.a * localResolution,\n        mat.b * localResolution,\n        mat.c * localResolution,\n        mat.d * localResolution,\n        mat.tx * contextResolution,\n        mat.ty * contextResolution\n      );\n    }\n  }\n  /**\n   * Clears the current render target, optionally filling with a color.\n   * @param clearColor - Color to fill after clearing.\n   * @param alpha - Alpha override for the clear color.\n   */\n  clear(clearColor, alpha) {\n    const context = this.activeContext;\n    const renderer = this._renderer;\n    context.clearRect(0, 0, renderer.width, renderer.height);\n    if (clearColor) {\n      const color = Color.shared.setValue(clearColor);\n      context.globalAlpha = alpha ?? color.alpha;\n      context.fillStyle = color.toHex();\n      context.fillRect(0, 0, renderer.width, renderer.height);\n      context.globalAlpha = 1;\n    }\n  }\n  /**\n   * Sets the active blend mode.\n   * @param blendMode - Pixi blend mode.\n   */\n  setBlendMode(blendMode) {\n    if (this._activeBlendMode === blendMode) return;\n    this._activeBlendMode = blendMode;\n    this._outerBlend = false;\n    const mappedBlend = this.blendModes[blendMode];\n    if (!mappedBlend) {\n      if (!this._warnedBlendModes.has(blendMode)) {\n        console.warn(\n          `CanvasRenderer: blend mode \"${blendMode}\" is not supported in Canvas2D; falling back to \"source-over\".`\n        );\n        this._warnedBlendModes.add(blendMode);\n      }\n      this.activeContext.globalCompositeOperation = \"source-over\";\n      return;\n    }\n    this.activeContext.globalCompositeOperation = mappedBlend;\n  }\n  /** Releases context references. */\n  destroy() {\n    this.rootContext = null;\n    this.activeContext = null;\n    this._warnedBlendModes.clear();\n  }\n}\n/** @ignore */\nCanvasContextSystem.extension = {\n  type: [\n    ExtensionType.CanvasSystem\n  ],\n  name: \"canvasContext\"\n};\n\nexport { CanvasContextSystem };\n\n", "import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass CanvasLimitsSystem {\n  constructor() {\n    this.maxTextures = 16;\n    this.maxBatchableTextures = 16;\n    this.maxUniformBindings = 0;\n  }\n  init() {\n  }\n}\n/** @ignore */\nCanvasLimitsSystem.extension = {\n  type: [\n    ExtensionType.CanvasSystem\n  ],\n  name: \"limits\"\n};\n\nexport { CanvasLimitsSystem };\n\n", "import { Color } from '../../../../color/Color.mjs';\nimport { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource.mjs';\n\n\"use strict\";\nclass CanvasRenderTargetAdaptor {\n  /**\n   * Initializes the adaptor.\n   * @param renderer - Canvas renderer instance.\n   * @param renderTargetSystem - The render target system.\n   * @advanced\n   */\n  init(renderer, renderTargetSystem) {\n    this._renderer = renderer;\n    this._renderTargetSystem = renderTargetSystem;\n  }\n  /**\n   * Creates a GPU render target for canvas.\n   * @param renderTarget - Render target to initialize.\n   * @advanced\n   */\n  initGpuRenderTarget(renderTarget) {\n    const colorTexture = renderTarget.colorTexture;\n    const { canvas, context } = this._ensureCanvas(colorTexture);\n    return {\n      canvas,\n      context,\n      width: canvas.width,\n      height: canvas.height\n    };\n  }\n  /**\n   * Resizes the backing canvas for a render target.\n   * @param renderTarget - Render target to resize.\n   * @advanced\n   */\n  resizeGpuRenderTarget(renderTarget) {\n    const colorTexture = renderTarget.colorTexture;\n    const { canvas } = this._ensureCanvas(colorTexture);\n    canvas.width = renderTarget.pixelWidth;\n    canvas.height = renderTarget.pixelHeight;\n  }\n  /**\n   * Starts a render pass on the canvas target.\n   * @param renderTarget - Target to render to.\n   * @param clear - Clear mode.\n   * @param clearColor - Optional clear color.\n   * @param viewport - Optional viewport.\n   * @advanced\n   */\n  startRenderPass(renderTarget, clear, clearColor, viewport) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    this._renderer.canvasContext.activeContext = gpuRenderTarget.context;\n    this._renderer.canvasContext.activeResolution = renderTarget.resolution;\n    if (clear) {\n      this.clear(renderTarget, clear, clearColor, viewport);\n    }\n  }\n  /**\n   * Clears the render target.\n   * @param renderTarget - Target to clear.\n   * @param _clear - Clear mode (unused).\n   * @param clearColor - Optional clear color.\n   * @param viewport - Optional viewport rectangle.\n   * @advanced\n   */\n  clear(renderTarget, _clear, clearColor, viewport) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const context = gpuRenderTarget.context;\n    const bounds = viewport || { x: 0, y: 0, width: renderTarget.pixelWidth, height: renderTarget.pixelHeight };\n    context.setTransform(1, 0, 0, 1, 0, 0);\n    context.clearRect(bounds.x, bounds.y, bounds.width, bounds.height);\n    if (clearColor) {\n      const color = Color.shared.setValue(clearColor);\n      if (color.alpha > 0) {\n        context.globalAlpha = color.alpha;\n        context.fillStyle = color.toHex();\n        context.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);\n        context.globalAlpha = 1;\n      }\n    }\n  }\n  /**\n   * Finishes the render pass (no-op for canvas).\n   * @advanced\n   */\n  finishRenderPass() {\n  }\n  /**\n   * Copies a render target into a texture source.\n   * @param {RenderTarget} sourceRenderSurfaceTexture - Source render target.\n   * @param {Texture} destinationTexture - Destination texture.\n   * @param {object} originSrc - Source origin.\n   * @param {number} originSrc.x - Source x origin.\n   * @param {number} originSrc.y - Source y origin.\n   * @param {object} size - Copy size.\n   * @param {number} size.width - Copy width.\n   * @param {number} size.height - Copy height.\n   * @param {object} [originDest] - Destination origin.\n   * @param {number} originDest.x - Destination x origin.\n   * @param {number} originDest.y - Destination y origin.\n   * @advanced\n   */\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    const sourceGpuTarget = this._renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);\n    const sourceCanvas = sourceGpuTarget.canvas;\n    const destSource = destinationTexture.source;\n    const { context } = this._ensureCanvas(destSource);\n    const dx = originDest?.x ?? 0;\n    const dy = originDest?.y ?? 0;\n    context.drawImage(\n      sourceCanvas,\n      originSrc.x,\n      originSrc.y,\n      size.width,\n      size.height,\n      dx,\n      dy,\n      size.width,\n      size.height\n    );\n    destSource.update();\n    return destinationTexture;\n  }\n  /**\n   * Destroys a GPU render target (no-op for canvas).\n   * @param _gpuRenderTarget - Target to destroy.\n   * @advanced\n   */\n  destroyGpuRenderTarget(_gpuRenderTarget) {\n  }\n  _ensureCanvas(source) {\n    let canvas = source.resource;\n    if (!canvas || !CanvasSource.test(canvas)) {\n      canvas = DOMAdapter.get().createCanvas(source.pixelWidth, source.pixelHeight);\n      source.resource = canvas;\n    }\n    if (canvas.width !== source.pixelWidth || canvas.height !== source.pixelHeight) {\n      canvas.width = source.pixelWidth;\n      canvas.height = source.pixelHeight;\n    }\n    const context = canvas.getContext(\"2d\");\n    return { canvas, context };\n  }\n}\n\nexport { CanvasRenderTargetAdaptor };\n\n", "import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem.mjs';\nimport { CanvasRenderTargetAdaptor } from './CanvasRenderTargetAdaptor.mjs';\n\n\"use strict\";\nclass CanvasRenderTargetSystem extends RenderTargetSystem {\n  constructor(renderer) {\n    super(renderer);\n    this.adaptor = new CanvasRenderTargetAdaptor();\n    this.adaptor.init(renderer, this);\n  }\n}\n/** @ignore */\nCanvasRenderTargetSystem.extension = {\n  type: [ExtensionType.CanvasSystem],\n  name: \"renderTarget\"\n};\n\nexport { CanvasRenderTargetSystem };\n\n", "import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { canvasUtils } from '../utils/canvasUtils.mjs';\n\n\"use strict\";\nclass CanvasTextureSystem {\n  /**\n   * @param renderer - The owning CanvasRenderer.\n   */\n  constructor(renderer) {\n    void renderer;\n  }\n  /** Initializes the system (no-op for canvas). */\n  init() {\n  }\n  /**\n   * Initializes a texture source (no-op for canvas).\n   * @param _source - Texture source.\n   */\n  initSource(_source) {\n  }\n  /**\n   * Creates a canvas containing the texture's frame.\n   * @param texture - Texture to render.\n   */\n  generateCanvas(texture) {\n    const canvas = DOMAdapter.get().createCanvas();\n    const context = canvas.getContext(\"2d\");\n    const source = canvasUtils.getCanvasSource(texture);\n    if (!source) {\n      return canvas;\n    }\n    const frame = texture.frame;\n    const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;\n    const sx = frame.x * resolution;\n    const sy = frame.y * resolution;\n    const sw = frame.width * resolution;\n    const sh = frame.height * resolution;\n    canvas.width = Math.ceil(sw);\n    canvas.height = Math.ceil(sh);\n    context.drawImage(\n      source,\n      sx,\n      sy,\n      sw,\n      sh,\n      0,\n      0,\n      sw,\n      sh\n    );\n    return canvas;\n  }\n  /**\n   * Reads pixel data from a texture.\n   * @param texture - Texture to read.\n   */\n  getPixels(texture) {\n    const canvas = this.generateCanvas(texture);\n    const context = canvas.getContext(\"2d\", { willReadFrequently: true });\n    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n    return {\n      pixels: imageData.data,\n      width: canvas.width,\n      height: canvas.height\n    };\n  }\n  /** Destroys the system (no-op for canvas). */\n  destroy() {\n  }\n}\n/** @ignore */\nCanvasTextureSystem.extension = {\n  type: [\n    ExtensionType.CanvasSystem\n  ],\n  name: \"texture\"\n};\n\nexport { CanvasTextureSystem };\n\n", "import { extensions, ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { CustomRenderPipe } from '../../../scene/container/CustomRenderPipe.mjs';\nimport { RenderGroupPipe } from '../../../scene/container/RenderGroupPipe.mjs';\nimport { CanvasGraphicsAdaptor } from '../../../scene/graphics/canvas/CanvasGraphicsAdaptor.mjs';\nimport { SpritePipe } from '../../../scene/sprite/SpritePipe.mjs';\nimport { CanvasBatchAdaptor } from '../../batcher/canvas/CanvasBatchAdaptor.mjs';\nimport { BatcherPipe } from '../../batcher/shared/BatcherPipe.mjs';\nimport { AlphaMaskPipe } from '../../mask/alpha/AlphaMaskPipe.mjs';\nimport { CanvasColorMaskPipe } from '../../mask/color/CanvasColorMaskPipe.mjs';\nimport { CanvasStencilMaskPipe } from '../../mask/stencil/CanvasStencilMaskPipe.mjs';\nimport { BlendModePipe } from '../shared/blendModes/BlendModePipe.mjs';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer.mjs';\nimport { SharedSystems } from '../shared/system/SharedSystems.mjs';\nimport { RendererType } from '../types.mjs';\nimport { CanvasContextSystem } from './CanvasContextSystem.mjs';\nimport { CanvasLimitsSystem } from './CanvasLimitsSystem.mjs';\nimport { CanvasRenderTargetSystem } from './renderTarget/CanvasRenderTargetSystem.mjs';\nimport { CanvasTextureSystem } from './texture/CanvasTextureSystem.mjs';\n\n\"use strict\";\nconst DefaultCanvasSystems = [\n  ...SharedSystems,\n  CanvasContextSystem,\n  CanvasLimitsSystem,\n  CanvasTextureSystem,\n  CanvasRenderTargetSystem\n];\nconst DefaultCanvasPipes = [\n  BlendModePipe,\n  BatcherPipe,\n  SpritePipe,\n  RenderGroupPipe,\n  AlphaMaskPipe,\n  CanvasStencilMaskPipe,\n  CanvasColorMaskPipe,\n  CustomRenderPipe\n];\nconst DefaultCanvasAdapters = [\n  CanvasBatchAdaptor,\n  CanvasGraphicsAdaptor\n];\nconst systems = [];\nconst renderPipes = [];\nconst renderPipeAdaptors = [];\nextensions.handleByNamedList(ExtensionType.CanvasSystem, systems);\nextensions.handleByNamedList(ExtensionType.CanvasPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.CanvasPipesAdaptor, renderPipeAdaptors);\nextensions.add(...DefaultCanvasSystems, ...DefaultCanvasPipes, ...DefaultCanvasAdapters);\nclass CanvasRenderer extends AbstractRenderer {\n  constructor() {\n    const systemConfig = {\n      name: \"canvas\",\n      type: RendererType.CANVAS,\n      systems,\n      renderPipes,\n      renderPipeAdaptors\n    };\n    super(systemConfig);\n  }\n}\n\nexport { CanvasRenderer };\n\n"],
  "mappings": "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",
  "names": ["_CanvasBatchAdaptor", "_CanvasGraphicsContextSystem", "buildRoundedRectPath", "buildShapePath", "addHolePaths", "tempMatrix"]
}
